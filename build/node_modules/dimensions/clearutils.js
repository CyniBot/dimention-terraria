"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const packettypes_1 = require("dimensions/packettypes");
const PlayerActive = require("terraria-packet/src/packet/Packet_PlayerActive.gen");
const NpcUpdate = require("terraria-packet/src/packet/Packet_NpcUpdate.gen");
const ItemDropUpdate = require("terraria-packet/src/packet/Packet_ItemDropUpdate.gen");
class ClearUtils {
    static clearPlayers(client) {
        const playerIDs = Object.keys(client.server.entityTracking.players);
        for (var i = 0, len = playerIDs.length; i < len; i++) {
            if (parseInt(playerIDs[i]) === client.player.id)
                continue;
            ClearUtils.clearPlayer(client, parseInt(playerIDs[i]));
        }
    }
    static clearPlayer(client, playerIndex) {
        const data = PlayerActive.toBuffer({ playerId: playerIndex, active: false });
        const playerActive = { packetType: packettypes_1.default.PlayerActive, data };
        const playerActivePacket = client.server.getPacketHandler().handlePacket(client.server, playerActive);
        if (playerActivePacket !== null) {
            client.socket.write(playerActivePacket);
        }
    }
    static clearNPCs(client) {
        for (const npc of client.server.entityTracking.NPCs) {
            if (typeof npc !== "undefined") {
                ClearUtils.clearNPC(client, npc.index);
            }
        }
    }
    static clearNPC(client, npcIndex) {
        const data = NpcUpdate.toBuffer({
            npcSlotId: npcIndex,
            npcTypeId: 0,
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            target: 0,
            directionX: false,
            directionY: false,
            ai: [undefined, undefined, undefined, undefined],
            spriteDirection: false,
            life: {
                TAG: "Byte",
                _0: 0
            },
            releaseOwner: undefined,
            playerCountScale: undefined,
            strengthMultiplier: undefined,
            spawnedFromStatue: false
        });
        const packet = { packetType: packettypes_1.default.NPCUpdate, data };
        const finalPacket = client.server.getPacketHandler().handlePacket(client.server, packet);
        if (finalPacket !== null) {
            client.socket.write(packet.data);
        }
        client.server.entityTracking.NPCs[npcIndex] = undefined;
    }
    static clearItems(client) {
        for (const item of client.server.entityTracking.items) {
            if (typeof item !== "undefined") {
                ClearUtils.clearItem(client, item.slot);
            }
        }
    }
    static clearItem(client, itemIndex) {
        const data = ItemDropUpdate.toBuffer({
            itemDropId: itemIndex,
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            stack: 0,
            prefix: 0,
            noDelay: 0,
            itemId: 0
        });
        const updateItemDrop = {
            data,
            packetType: packettypes_1.default.UpdateItemDrop,
        };
        const updateItemDropPacket = client.server.getPacketHandler().handlePacket(client.server, updateItemDrop);
        if (updateItemDropPacket !== null) {
            client.socket.write(updateItemDropPacket);
        }
    }
}
exports.default = ClearUtils;

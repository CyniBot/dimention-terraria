"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const packettypes_1 = require("dimensions/packettypes");
const packetreader_1 = require("dimensions/packets/packetreader");
const item_1 = require("dimensions/item");
const clientstate_1 = require("dimensions/clientstate");
const ConnectRequest = require("terraria-packet/src/packet/Packet_ConnectRequest.gen");
const PlayerInfo = require("terraria-packet/src/packet/Packet_PlayerInfo.gen");
const PlayerBuffsSet = require("terraria-packet/src/packet/Packet_PlayerBuffsSet.gen");
const PlayerBuffAdd = require("terraria-packet/src/packet/Packet_PlayerBuffAdd.gen");
const PlayerInventorySlot = require("terraria-packet/src/packet/Packet_PlayerInventorySlot.gen");
const PlayerMana = require("terraria-packet/src/packet/Packet_PlayerMana.gen");
const PlayerHealth = require("terraria-packet/src/packet/Packet_PlayerHealth.gen");
const PlayerUpdate = require("terraria-packet/src/packet/Packet_PlayerUpdate.gen");
const ClientUuid = require("terraria-packet/src/packet/Packet_ClientUuid.gen");
class ClientPacketHandler {
    /* Checks whether the packet was handled by extensions prior to being processed by this class */
    runPriorHandlers(client, packet) {
        let handlers = client.globalHandlers.extensions;
        let handled = false;
        for (let key in handlers) {
            let handler = handlers[key];
            if (typeof handler.priorPacketHandlers !== 'undefined' && typeof handler.priorPacketHandlers.clientHandler !== 'undefined') {
                handled = handler.priorPacketHandlers.clientHandler.handlePacket(client, packet);
                if (handled) {
                    break;
                }
            }
        }
        return handled;
    }
    /* Checks whether the packet was handled by extensions after being processed by this class */
    runPostHandlers(client, packet) {
        let handlers = client.globalHandlers.extensions;
        let handled = false;
        for (let key in handlers) {
            let handler = handlers[key];
            if (typeof handler.postPacketHandlers !== 'undefined' && typeof handler.postPacketHandlers.clientHandler !== 'undefined') {
                handled = handler.postPacketHandlers.clientHandler.handlePacket(client, packet);
                if (handled) {
                    break;
                }
            }
        }
        return handled;
    }
    /* Runs the packet through extension handlers and runs any appropriate handlers of this class */
    handlePacket(client, rawPacket) {
        let priorHandled = this.runPriorHandlers(client, rawPacket);
        if (priorHandled) {
            return null;
        }
        let packetType = rawPacket.packetType;
        let handled = false;
        // Set current client while we handle this packet
        this.currentClient = client;
        switch (packetType) {
            case packettypes_1.default.ConnectRequest:
                handled = this.handleConnectRequest(rawPacket);
                break;
            case packettypes_1.default.PlayerInfo:
                handled = this.handlePlayerInfo(rawPacket);
                break;
            case packettypes_1.default.UpdatePlayerBuff:
                handled = this.handleUpdatePlayerBuff(rawPacket);
                break;
            case packettypes_1.default.AddPlayerBuff:
                handled = this.handleAddPlayerBuff(rawPacket);
                break;
            case packettypes_1.default.PlayerInventorySlot:
                handled = this.handlePlayerInventorySlot(rawPacket);
                break;
            case packettypes_1.default.PlayerMana:
                handled = this.handlePlayerMana(rawPacket);
                break;
            case packettypes_1.default.PlayerHP:
                handled = this.handlePlayerHP(rawPacket);
                break;
            case packettypes_1.default.UpdatePlayer:
                handled = this.handleUpdatePlayer(rawPacket);
                break;
            case packettypes_1.default.UpdateItemDrop:
                handled = this.handleUpdateItemDrop(rawPacket);
                break;
            case packettypes_1.default.UpdateItemOwner:
                handled = this.handleUpdateItemOwner(rawPacket);
                break;
            case packettypes_1.default.ContinueConnecting2:
                if (this.currentClient.state === clientstate_1.default.FreshConnection) {
                    // Finished sending inventory
                    this.currentClient.state = clientstate_1.default.FinishinedSendingInventory;
                }
                break;
            case packettypes_1.default.SpawnPlayer:
                handled = this.handleSpawnPlayer(rawPacket);
                break;
            case packettypes_1.default.LoadNetModule:
                handled = this.handleLoadNetModule(rawPacket);
                break;
            case packettypes_1.default.DimensionsUpdate:
                // Client cannot send 67 (It's used by Dimensions to communicate special info)
                handled = true;
                break;
            case packettypes_1.default.ClientUUID:
                handled = this.handleClientUUID(rawPacket);
                break;
            case packettypes_1.default.SetPlayerStealth:
            case packettypes_1.default.PlayerHurtV2:
            case packettypes_1.default.PlayerZone:
                handled = this.handlePotentialEarlyPacket(rawPacket);
                break;
        }
        if (handled) {
            return null;
        }
        let postHandled = this.runPostHandlers(client, rawPacket);
        if (postHandled) {
            return null;
        }
        return rawPacket.data;
    }
    handleConnectRequest(packet) {
        var _a;
        if (this.currentClient.version === "unknown") {
            const connectRequest = ConnectRequest.parse(packet.data);
            this.currentClient.version = (_a = connectRequest === null || connectRequest === void 0 ? void 0 : connectRequest.version) !== null && _a !== void 0 ? _a : "unknown";
        }
        return false;
    }
    /* Updates tracked visuals for player to restore them when they switch from
     * an SSC to a non-SSC server */
    handlePlayerInfo(packet) {
        var _a;
        const playerInfo = PlayerInfo.parse(packet.data);
        if (typeof playerInfo === 'undefined') {
            return true;
        }
        const player = this.currentClient.player;
        if (player.name !== playerInfo.name) {
            if (player.allowedNameChange) {
                this.currentClient.setName(playerInfo.name);
            }
            else if (((_a = this.currentClient.options.nameChanges) === null || _a === void 0 ? void 0 : _a.mode) === "rewrite") {
                const data = PlayerInfo.toBuffer(Object.assign(Object.assign({}, playerInfo), { playerId: this.currentClient.player.id, name: player.name }));
                packet.data = data;
            }
        }
        if (player.allowedCharacterChange) {
            player.skinVariant = playerInfo.skinVariant;
            player.hair = playerInfo.hair;
            player.hairDye = playerInfo.hairDye;
            player.hideVisuals = playerInfo.hideVisuals;
            player.hideVisuals2 = playerInfo.hideVisuals2;
            player.hideMisc = playerInfo.hideMisc;
            player.hairColor = playerInfo.hairColor;
            player.skinColor = playerInfo.skinColor;
            player.eyeColor = playerInfo.eyeColor;
            player.shirtColor = playerInfo.shirtColor;
            player.underShirtColor = playerInfo.underShirtColor;
            player.pantsColor = playerInfo.pantsColor;
            player.shoeColor = playerInfo.shoeColor;
            player.difficulty = playerInfo.difficulty;
            player.allowedCharacterChange = false;
        }
        return false;
    }
    /* Used to prevent invisibility buff from being sent to the server
     * for used when the config is set to blockInvis = true */
    handleUpdatePlayerBuff(packet) {
        const playerBuffsSet = PlayerBuffsSet.parse(packet.data);
        if (typeof playerBuffsSet === 'undefined') {
            return true;
        }
        let shouldBlockInvis = false;
        const blockInvis = this.currentClient.options.blockInvis;
        switch (blockInvis) {
            case true:
                shouldBlockInvis = true;
                break;
            case false:
                break;
            default:
                shouldBlockInvis = blockInvis.enabled && blockInvis.servers.some(server => server.toLowerCase() === this.currentClient.server.name.toLowerCase());
                break;
        }
        if (shouldBlockInvis) {
            const buffs = playerBuffsSet.buffs.map((buff) => {
                if (buff === 10) {
                    return 0;
                }
                return buff;
            });
            packet.data = PlayerBuffsSet.toBuffer({ playerId: this.currentClient.player.id, buffs });
        }
        // Prevent this being sent too early (causing kicked for invalid operation)
        if (this.currentClient.state !== clientstate_1.default.FullyConnected) {
            this.currentClient.packetQueue.push(packet.data);
            return true;
        }
        return false;
    }
    /* Used to prevent invisibility buff from being sent to the server
     * for used when the config is set to blockInvis = true */
    handleAddPlayerBuff(packet) {
        const playerBuffAdd = PlayerBuffAdd.parse(packet.data);
        if (typeof playerBuffAdd === 'undefined') {
            return true;
        }
        let shouldBlockInvis = false;
        const blockInvis = this.currentClient.options.blockInvis;
        switch (blockInvis) {
            case true:
                shouldBlockInvis = true;
                break;
            case false:
                break;
            default:
                shouldBlockInvis = blockInvis.enabled && blockInvis.servers.some(server => server.toLowerCase() === this.currentClient.server.name.toLowerCase());
                break;
        }
        if (shouldBlockInvis) {
            return playerBuffAdd.buff === 10;
        }
        else {
            return false;
        }
    }
    /* Tracks the players inventory slots to restore them when they switch
     * from an SSC server to a Non-SSC server */
    handlePlayerInventorySlot(packet) {
        if ((this.currentClient.state === clientstate_1.default.FreshConnection || this.currentClient.state === clientstate_1.default.ConnectionSwitchEstablished) && !this.currentClient.waitingCharacterRestore) {
            const playerInventorySlot = PlayerInventorySlot.parse(packet.data);
            if (typeof playerInventorySlot === 'undefined') {
                return true;
            }
            const { slot, stack, prefix, itemId } = playerInventorySlot;
            this.currentClient.player.inventory[slot] = new item_1.default(slot, stack, prefix, itemId);
        }
        return false;
    }
    /* Tracks the player mana to restore it when they switch from an
     * SSC server to a Non-SSC server */
    handlePlayerMana(packet) {
        if (!this.currentClient.player.allowedManaChange)
            return false;
        const playerMana = PlayerMana.parse(packet.data);
        if (typeof playerMana === 'undefined') {
            return true;
        }
        const { mana } = playerMana;
        this.currentClient.player.mana = mana;
        this.currentClient.player.allowedManaChange = false;
        return false;
    }
    /* Tracks the player HP to restore it when they switch from an
     * SSC server to a Non-SSC server */
    handlePlayerHP(packet) {
        if (!this.currentClient.player.allowedLifeChange) {
            return false;
        }
        const playerHealth = PlayerHealth.parse(packet.data);
        if (typeof playerHealth === 'undefined') {
            return true;
        }
        const { health } = playerHealth;
        this.currentClient.player.life = health;
        this.currentClient.player.allowedLifeChange = false;
        // Prevent this being sent too early (causing kicked for invalid operation)
        if (this.currentClient.state !== clientstate_1.default.FullyConnected) {
            this.currentClient.packetQueue.push(packet.data);
            return true;
        }
        return false;
    }
    handleUpdatePlayer(packet) {
        const playerUpdate = PlayerUpdate.parse(packet.data);
        if (typeof playerUpdate === 'undefined') {
            return true;
        }
        // Prevent this being sent too early (causing kicked for invalid operation)
        if (this.currentClient.state !== clientstate_1.default.FullyConnected) {
            this.currentClient.packetQueue.push(packet.data);
            return true;
        }
        return false;
    }
    /* Prevents the player sending the item drop packet too early
     * which causes them to be kicked. It also adds it to the packet queue
     * so that it may be sent when the client has fully connected (and wont
     * get kicked for sending it) */
    handleUpdateItemDrop(packet) {
        // Prevent this being sent too early (causing kicked for invalid operation)
        if (this.currentClient.state !== clientstate_1.default.FullyConnected) {
            this.currentClient.packetQueue.push(packet.data);
            return true;
        }
        return false;
    }
    /* Prevents the player sending the item owner packet too early
     * which causes them to be kicked. It also adds it to the packet queue
     * so that it may be sent when the client has fully connected (and wont
     * get kicked for sending it)
     *
     * Note: This packet is important for tShock SSC to work. If this was
     *       prevented outright, SSC would be broken (inventory would be unchangable) */
    handleUpdateItemOwner(packet) {
        // Prevent this being sent too early (causing kicked for invalid operation)
        if (this.currentClient.state !== clientstate_1.default.FullyConnected) {
            this.currentClient.packetQueue.push(packet.data);
            return true;
        }
        return false;
    }
    handleSpawnPlayer(_packet) {
        if (this.currentClient.state === clientstate_1.default.FinishinedSendingInventory) {
            this.currentClient.state = clientstate_1.default.FullyConnected;
        }
        return false;
    }
    /* Handles when a net module update is sent from the client (used only for chat at this time) */
    handleLoadNetModule(packet) {
        let handled = false;
        let reader = new packetreader_1.default(packet.data);
        let moduleId = reader.readUInt16();
        if (moduleId === 1) {
            // ID is either Say or Emote
            // @ts-ignore
            let _commandId = reader.readString();
            let chatMessage = reader.readString();
            handled = this.handleChatMessage(chatMessage);
        }
        return handled;
    }
    /* Handles any commands sent by the client given they start with "/" */
    handleChatMessage(chatMessage) {
        let handled = false;
        // If chat message is a command
        if (chatMessage.length > 1 && chatMessage.substr(0, 1) === "/") {
            let command = this.currentClient.globalHandlers.command.parseCommand(chatMessage);
            handled = this.currentClient.globalHandlers.command.handle(command, this.currentClient);
        }
        return handled;
    }
    /* Updates the clients current tracked UUID */
    handleClientUUID(packet) {
        const clientUuid = ClientUuid.parse(packet.data);
        if (typeof clientUuid === 'undefined') {
            return true;
        }
        this.currentClient.UUID = clientUuid.uuid;
        return false;
    }
    /* Some packets should not be sent early to avoid kick for invalid operation at this state */
    handlePotentialEarlyPacket(packet) {
        // Prevent this being sent too early (causing kicked for invalid operation)
        if (this.currentClient.state !== clientstate_1.default.FullyConnected) {
            this.currentClient.packetQueue.push(packet.data);
            return true;
        }
        return false;
    }
}
exports.default = ClientPacketHandler;

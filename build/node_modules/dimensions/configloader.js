"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigSettings = void 0;
const Language = require("dimensions/language");
const assert = require("assert");
const unvalidatedConfig = require(`../../../config.js`).ConfigSettings;
const debuffOnSwitch = { enabled: true, buffTypes: [/* Webbed */ 149, /* Stoned */ 156], debuffTimeInSeconds: 5 };
const disconnectOnKick = { type: "never" };
const blacklist = { enabled: false };
let validatedConfig = {
    servers: unvalidatedConfig.servers,
    options: Object.assign(Object.assign({}, unvalidatedConfig.options), { blacklist,
        debuffOnSwitch,
        disconnectOnKick, language: Language.english }),
};
try {
    if (typeof unvalidatedConfig.options.nameChanges !== "undefined") {
        assert(unvalidatedConfig.options.nameChanges.mode === "legacy" || unvalidatedConfig.options.nameChanges.mode === "rewrite", "nameChanges.mode must be either 'legacy' or 'rewrite'");
        assert(Array.isArray(unvalidatedConfig.options.nameChanges.exclusions), "nameChanges.exclusions must be an array");
    }
    if (typeof unvalidatedConfig.options.debuffOnSwitch !== "undefined") {
        if (!unvalidatedConfig.options.debuffOnSwitch.enabled) {
            debuffOnSwitch.enabled = false;
        }
        else {
            if (typeof unvalidatedConfig.options.debuffOnSwitch.buffTypes !== "undefined") {
                debuffOnSwitch.buffTypes = unvalidatedConfig.options.debuffOnSwitch.buffTypes;
            }
            if (typeof unvalidatedConfig.options.debuffOnSwitch.debuffTimeInSeconds !== "undefined")
                debuffOnSwitch.debuffTimeInSeconds = unvalidatedConfig.options.debuffOnSwitch.debuffTimeInSeconds;
        }
    }
    if (typeof unvalidatedConfig.options.disconnectOnKick !== "undefined") {
        if (unvalidatedConfig.options.disconnectOnKick.type === "onKickReasonPrefix") {
            assert(Array.isArray(unvalidatedConfig.options.disconnectOnKick.kickReasonPrefixes), "disconnectOnKick.kickReasonPrefixes must be an array");
            validatedConfig.options.disconnectOnKick = {
                type: "onKickReasonPrefix",
                kickReasonPrefixes: unvalidatedConfig.options.disconnectOnKick.kickReasonPrefixes,
            };
        }
        else {
            unvalidatedConfig.options.disconnectOnKick.type = unvalidatedConfig.options.disconnectOnKick.type;
        }
    }
    if (typeof unvalidatedConfig.options.language !== "undefined") {
        switch (unvalidatedConfig.options.language.toLowerCase()) {
            case Language.english.isoCode.toLowerCase():
            case Language.english.name.toLowerCase():
            case Language.english.englishName.toLowerCase():
                break;
            case Language.chinese.isoCode.toLowerCase():
            case Language.chinese.name.toLowerCase():
            case Language.chinese.englishName.toLowerCase():
                validatedConfig.options.language = Language.chinese;
                break;
            default:
                console.log("Unrecognised language:", unvalidatedConfig.options.language);
                process.exit(1);
        }
    }
    if (typeof unvalidatedConfig.options.languageOverrides !== "undefined") {
        validatedConfig.options.language.phrases = Object.assign(Object.assign({}, validatedConfig.options.language.phrases), unvalidatedConfig.options.languageOverrides);
    }
    validatedConfig.options.blacklist.enabled = (_a = unvalidatedConfig.options.blacklist.enabled) !== null && _a !== void 0 ? _a : false;
    if (validatedConfig.options.blacklist.enabled) {
        assert(typeof unvalidatedConfig.options.blacklist.hostname !== "undefined", "Blacklist enabled but no hostname provided");
        assert(typeof unvalidatedConfig.options.blacklist.path !== "undefined", "Blacklist enabled but no path provided");
        assert(typeof unvalidatedConfig.options.blacklist.port !== "undefined", "Blacklist enabled but no port provided");
        assert(typeof unvalidatedConfig.options.blacklist.apiKey !== "undefined", "Blacklist enabled but no api key provided");
        assert(unvalidatedConfig.options.blacklist.errorPolicy === "AllowJoining" || unvalidatedConfig.options.blacklist.errorPolicy === "DenyJoining", "Blacklist errorPolicy must be either 'AllowJoining' or 'DenyJoining'");
        validatedConfig.options.blacklist.hostname = unvalidatedConfig.options.blacklist.hostname;
        validatedConfig.options.blacklist.path = unvalidatedConfig.options.blacklist.path;
        validatedConfig.options.blacklist.port = unvalidatedConfig.options.blacklist.port;
        validatedConfig.options.blacklist.apiKey = unvalidatedConfig.options.blacklist.apiKey;
        validatedConfig.options.blacklist.errorPolicy = unvalidatedConfig.options.blacklist.errorPolicy;
    }
}
catch (e) {
    console.log("Error validating config:");
    throw e;
}
exports.ConfigSettings = validatedConfig;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("dimensions/utils");
const utils_2 = require("dimensions/utils");
const PlayerSlotSet = require("terraria-packet/src/packet/Packet_PlayerSlotSet.gen");
const Parser = require("terraria-packet/src/Parser.gen");
var ClientState;
(function (ClientState) {
    ClientState[ClientState["StartOfConnection"] = 0] = "StartOfConnection";
    ClientState[ClientState["AssignedClientId"] = 1] = "AssignedClientId";
    ClientState[ClientState["SentPlayerInfo"] = 2] = "SentPlayerInfo";
    ClientState[ClientState["SentUuid"] = 3] = "SentUuid";
})(ClientState || (ClientState = {}));
class BlacklistCheckClient {
    constructor(settings) {
        this.settings = settings;
        this.state = ClientState.StartOfConnection;
        this.bufferPacket = Buffer.alloc(0);
        this.packetsReceived = [];
        this.disposed = false;
        this.state = ClientState.AssignedClientId;
    }
    setupCallbacks(args) {
        this.clientAcceptedCb = args.clientAcceptedCb;
        this.clientBlacklistedCb = args.clientBlacklistedCb;
        this.errorCheckingBlacklistCb = args.errorCheckingBlacklistCb;
        this.packetErrorCheckingBlacklistCb = args.packetErrorCheckingBlacklistCb;
        this.settings.clientArgs.socket.on('data', this.handleData.bind(this));
        this.settings.clientArgs.socket.on('error', this.handleError.bind(this));
        this.settings.clientArgs.socket.on('timeout', this.handleTimeout.bind(this));
        this.settings.clientArgs.socket.on('close', () => {
            if (this.disposed) {
                return;
            }
            args.disconnectCb();
            this.dispose();
        });
        this.settings.clientArgs.socket.write(PlayerSlotSet.toBuffer(0));
    }
    handleData(data) {
        let bufferPacket = this.bufferPacket;
        let entireData = Buffer.concat([bufferPacket, data]);
        // Get the individual packets from the data
        let entireDataInfo = (0, utils_1.getPacketsFromBuffer)(entireData);
        if (entireDataInfo.type === "InvalidPacketLength") {
            this.dispose();
            this.packetErrorCheckingBlacklistCb(new Error(`Invalid packet length ${entireDataInfo.length}`));
            return;
        }
        // Update Buffer Packet using the new incomplete packet (if any)
        this.bufferPacket = entireDataInfo.bufferPacket;
        const packets = entireDataInfo.packets;
        this.packetsReceived.push(...packets);
        for (const packet of packets) {
            this.handlePacket(packet);
        }
    }
    handlePacket(rawPacket) {
        if (this.disposed) {
            return;
        }
        const packet = Parser.parseLazy(rawPacket.data, false);
        if (packet == undefined) {
            return;
        }
        switch (packet.TAG) {
            case "PlayerInfo":
                if (this.state !== ClientState.AssignedClientId) {
                    this.dispose();
                    this.packetErrorCheckingBlacklistCb(new Error("Client info packet received before assigning client ID"));
                    return;
                }
                const playerInfo = packet._0.VAL();
                if (playerInfo === undefined) {
                    this.dispose();
                    this.packetErrorCheckingBlacklistCb(new Error("Client info packet could not be parsed"));
                    return;
                }
                this.name = playerInfo.name;
                this.state = ClientState.SentPlayerInfo;
                break;
            case "ClientUuid":
                if (this.state !== ClientState.SentPlayerInfo) {
                    this.dispose();
                    this.packetErrorCheckingBlacklistCb(new Error("Client UUID packet received before player info"));
                    return;
                }
                const clientUuid = packet._0.VAL();
                const ip = (0, utils_2.getProperIP)(this.settings.clientArgs.socket.remoteAddress);
                if (clientUuid === undefined) {
                    this.dispose();
                    this.packetErrorCheckingBlacklistCb(new Error("Client UUID packet could not be parsed"));
                    return;
                }
                if (this.name === undefined) {
                    this.dispose();
                    this.packetErrorCheckingBlacklistCb(new Error("Client name missing"));
                    return;
                }
                if (ip === undefined) {
                    this.dispose();
                    this.packetErrorCheckingBlacklistCb(new Error("Client IP could not be parsed"));
                    return;
                }
                this.settings.blacklist.checkInformation(this.name, ip, clientUuid.uuid).then((isBlacklisted) => {
                    if (this.disposed) {
                        return;
                    }
                    this.dispose();
                    if (isBlacklisted) {
                        this.clientBlacklistedCb();
                    }
                    else {
                        this.clientAcceptedCb(this.bufferPacket, this.packetsReceived);
                    }
                }).catch((e) => {
                    if (this.disposed) {
                        return;
                    }
                    this.dispose();
                    this.errorCheckingBlacklistCb(this.bufferPacket, this.packetsReceived, e);
                });
                break;
        }
    }
    handleError(err) {
        console.error("Error with client", err);
    }
    handleTimeout() {
        console.error("Client timed out");
    }
    dispose() {
        this.settings.clientArgs.socket.removeAllListeners();
        this.disposed = true;
    }
}
exports.default = BlacklistCheckClient;

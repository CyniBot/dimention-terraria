"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const redis = require("redis");
const errorhelper_1 = require("dimensions/errorhelper");
const listenserver_1 = require("dimensions/listenserver");
const configloader_1 = require("dimensions/configloader");
const clientcommandhandler_1 = require("dimensions/clientcommandhandler");
const terrariaserverpackethandler_1 = require("dimensions/terrariaserverpackethandler");
const extensions_1 = require("dimensions/extensions");
const clientpackethandler_1 = require("dimensions/clientpackethandler");
const restapi_1 = require("dimensions/restapi");
const blacklist_1 = require("dimensions/blacklist");
const reload = require("require-nocache");
/* The core that sets up the listen servers, rest api and handles reloading */
class Dimensions {
    constructor(logging) {
        this.servers = {};
        this.listenServers = {};
        this.serversDetails = {};
        this.connectionsTracker = new Map();
        this.connectRateTracker = new Map();
        this.extensionStorage = new Map();
        this.options = configloader_1.ConfigSettings.options;
        this.logging = logging;
        if (this.options.blacklist.enabled) {
            this.blacklist = new blacklist_1.default(this.options.blacklist);
        }
        this.handlers = {
            command: new clientcommandhandler_1.default(),
            clientPacketHandler: new clientpackethandler_1.default(),
            terrariaServerPacketHandler: new terrariaserverpackethandler_1.default(),
            extensions: {}
        };
        extensions_1.default.loadExtensions(this.handlers.extensions, this.listenServers, this.options.log, this.logging, this.extensionStorage);
        if (typeof this.options.redis !== "undefined" && this.options.redis.enabled) {
            this.setupRedis();
        }
        this.serversDetails = {};
        this.listenServers = {};
        this.servers = {};
        this.globalTracking = {
            names: {}
        };
        this.setupRoutes();
        // Starts a new RestAPI server. This mimics the status output of tShock's RestAPI and puts in the total count and all player names from all Dimensions
        if (this.options.restApi.enabled) {
            this.restApi = new restapi_1.default(this.options.restApi.port, this.globalTracking, this.serversDetails, this.servers, this.options.restApi.response, this.logging);
        }
    }
    setupRedis() {
        // Start a client listening on the dimensions_cli channel for commands, such as reload
        this.redisClient = redis.createClient({
            host: this.options.redis.host,
            port: this.options.redis.port
        });
        this.redisClient.subscribe('dimensions_cli');
        this.redisClient
            .on('message', (channel, message) => {
            if (channel === "dimensions_cli") {
                this.handleCommand(message);
            }
        })
            .on('error', (err) => {
            this.logging.error("RedisError: " + errorhelper_1.default.toMessage(err));
        });
    }
    /**
     * Starts a listen server per port in the config, giving it the routing servers it is responsible for
     */
    setupRoutes() {
        // Goes through each listen server object in the config
        for (let i = 0; i < configloader_1.ConfigSettings.servers.length; i++) {
            // Starts up a listen server on the specified port, and assigns the listed routing servers to this listen server
            const server = configloader_1.ConfigSettings.servers[i];
            // Adds each routing server to the shared servers object, used when a client wants to switch Dimension and needs the information for the socket
            for (let j = 0; j < configloader_1.ConfigSettings.servers[i].routingServers.length; j++) {
                this.servers[configloader_1.ConfigSettings.servers[i].routingServers[j].name.toLowerCase()] = configloader_1.ConfigSettings.servers[i].routingServers[j];
            }
            if (!("listenPort" in server)) {
                continue;
            }
            const listenKey = server.listenPort;
            const args = {
                blacklist: this.blacklist,
                globalHandlers: this.handlers,
                globalTracking: this.globalTracking,
                info: server,
                logging: this.logging,
                options: this.options,
                servers: this.servers,
                serversDetails: this.serversDetails,
                connectionsTracker: this.connectionsTracker,
                connectRateTracker: this.connectRateTracker
            };
            this.listenServers[listenKey] = new listenserver_1.default(args);
        }
    }
    /* Prints out the names currently used and the number of people on each Dimension */
    printServerCounts() {
        let serverKeys = Object.keys(this.servers);
        let info = "";
        for (let i = 0; i < serverKeys.length; i++) {
            info += "[" + serverKeys[i] + ": " + this.serversDetails[serverKeys[i]].clientCount + "] ";
        }
        console.log(this.globalTracking.names);
        console.log(info);
    }
    /* Handles commands received by the subscribed Redis channel */
    handleCommand(cmd) {
        switch (cmd) {
            case "players":
                this.printServerCounts();
                break;
            case "reload":
                this.reloadServers();
                break;
            case "reloadhandlers":
                this.reloadClientHandlers();
                this.reloadTerrariaServerHandlers();
                this.logging.info("Reloaded Packet Handlers.");
                break;
            case "reloadcmds":
                try {
                    let ClientCommandHandler = reload(module)('./clientcommandhandler.js', require).default;
                    this.handlers.command = new ClientCommandHandler();
                }
                catch (e) {
                    this.logging.error("Error loading Command Handler: " + errorhelper_1.default.toMessage(e));
                }
                this.logging.info("Reloaded Command Handler.");
                break;
            case "reloadextensions":
            case "reloadplugins":
                this.reloadExtensions();
                break;
            default:
                this.passOnReloadToExtensions();
                break;
        }
    }
    /* When a command is not directly handled by handleCommand, it comes through here and is
     * passed on to each extension in-case they have it as a command */
    passOnReloadToExtensions() {
        let handlers = this.handlers.extensions;
        for (let key in handlers) {
            let handler = handlers[key];
            if (handler.reloadable && typeof handler.reloadName !== 'undefined') {
                if (typeof handler.reload === 'function') {
                    handler.reload(require);
                }
            }
        }
    }
    /* Loads a new instance of ClientPacketHandler by requiring the file again */
    reloadClientHandlers() {
        try {
            let ClientPacketHandler = reload(module)('./clientpackethandler.js', require).default;
            this.handlers.clientPacketHandler = new ClientPacketHandler();
        }
        catch (e) {
            this.logging.error("Error loading Client Packet Handler: " + errorhelper_1.default.toMessage(e));
        }
    }
    /* Loads a new instance of TerrariaServerPacketHandler by requiring the file again */
    reloadTerrariaServerHandlers() {
        try {
            let TerrariaServerPacketHandler = reload(module)('./terrariaserverpackethandler.js').default;
            this.handlers.terrariaServerPacketHandler = new TerrariaServerPacketHandler();
        }
        catch (e) {
            this.logging.error("Error loading TerrariaServer Packet Handler: " + errorhelper_1.default.toMessage(e));
        }
    }
    /* Unloads and re-loads all extensions directly from their directories */
    reloadExtensions() {
        if (this.options.log.extensionLoad) {
            for (let key in this.handlers.extensions) {
                let extension = this.handlers.extensions[key];
                if (extension.unload) {
                    const storage = extension.unload();
                    if (typeof storage !== "undefined") {
                        this.extensionStorage.set(extension.name, storage);
                    }
                }
                if (this.options.log.extensionLoad) {
                    this.logging.info(`[Extension] ${extension.name} ${extension.version} unloaded.`);
                }
            }
        }
        this.handlers.extensions = {};
        Object.keys(require.cache).forEach(key => delete require.cache[key]);
        extensions_1.default.loadExtensions(this.handlers.extensions, this.listenServers, this.options.log, this.logging, this.extensionStorage);
    }
    /* Checks the config servers against the existing listen servers and updates any allocations
     * of each individual dimension to the appropriate listenserver, and will destroy any listenservers
     * that no longer should exist, and starts up new ones on the specified ports from the config */
    reloadServers() {
        var _a;
        try {
            let ConfigSettings = reload(module)('../../../config.js').ConfigSettings;
            if (ConfigSettings.options.restApi.enabled) {
                (_a = this.restApi) === null || _a === void 0 ? void 0 : _a.handleReload(ConfigSettings.options.restApi.port);
            }
            let currentRoster = {};
            let runAfterFinished = [];
            for (let i = 0; i < ConfigSettings.servers.length; i++) {
                const server = ConfigSettings.servers[i];
                if (!("listenPort" in server)) {
                    // Adds/updates each routing server (Dimension) to the shared servers object
                    for (var j = 0; j < ConfigSettings.servers[i].routingServers.length; j++) {
                        this.servers[ConfigSettings.servers[i].routingServers[j].name] = ConfigSettings.servers[i].routingServers[j];
                    }
                    continue;
                }
                const listenKey = server.listenPort.toString();
                // Checks if the listenServer for the specified port exists
                if (this.listenServers[listenKey]) {
                    // Ensures the listenServer has all the listed routing servers from the config for load-balancing/routing
                    this.listenServers[listenKey].updateInfo(server);
                    // Adds/updates each routing server (Dimension) to the shared servers object
                    for (var j = 0; j < ConfigSettings.servers[i].routingServers.length; j++) {
                        this.servers[ConfigSettings.servers[i].routingServers[j].name] = ConfigSettings.servers[i].routingServers[j];
                    }
                }
                else {
                    // If the listen server does not exist, it is added to be created after any existing ones that no longer exist are closed
                    runAfterFinished.push({
                        key: listenKey,
                        server: server,
                    });
                }
                currentRoster[listenKey] = 1;
            }
            const currentListenServers = Object.keys(this.listenServers);
            for (let i = 0; i < currentListenServers.length; i++) {
                // If the listen server is not in the config anymore, it is cleanly closed and removed
                if (!currentRoster[currentListenServers[i]]) {
                    this.listenServers[currentListenServers[i]].shutdown();
                    delete this.listenServers[currentListenServers[i]];
                }
            }
            let args;
            // Sets up any new listen servers and assigns them their routing servers
            for (let i = 0; i < runAfterFinished.length; i++) {
                args = {
                    blacklist: this.blacklist,
                    globalHandlers: this.handlers,
                    globalTracking: this.globalTracking,
                    info: runAfterFinished[i].server,
                    logging: this.logging,
                    options: this.options,
                    servers: this.servers,
                    serversDetails: this.serversDetails,
                    connectionsTracker: this.connectionsTracker,
                    connectRateTracker: this.connectRateTracker
                };
                this.listenServers[runAfterFinished[i].key] = new listenserver_1.default(args);
                for (let j = 0; j < runAfterFinished[i].server.routingServers.length; j++) {
                    this.servers[runAfterFinished[i].server.routingServers[j].name] = runAfterFinished[i].server.routingServers[j];
                }
            }
            // Update shared options object with new config options (logging options etc)
            let keys = Object.keys(this.options);
            for (let i = 0; i < keys.length; i++) {
                this.options[keys[i]] = ConfigSettings.options[keys[i]];
            }
        }
        catch (e) {
            this.logging.error("Error loading Config: " + errorhelper_1.default.toMessage(e));
        }
        this.logging.info("Reloaded Config.");
    }
    close() {
        if (typeof this.redisClient !== "undefined") {
            this.redisClient.quit();
        }
        if (typeof this.restApi !== "undefined") {
            this.restApi.close();
        }
        Object.keys(this.listenServers).forEach(key => this.listenServers[key].shutdown());
    }
}
exports.default = Dimensions;

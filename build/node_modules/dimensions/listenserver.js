"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListenServer = void 0;
const Net = require("net");
const utils_1 = require("dimensions/utils");
const client_1 = require("dimensions/client");
const packettypes_1 = require("dimensions/packettypes");
const packetwriter_1 = require("dimensions/packets/packetwriter");
const networktext_1 = require("dimensions/packets/networktext");
const stringutils_1 = require("dimensions/stringutils");
const errorhelper_1 = require("dimensions/errorhelper");
const blacklistcheckclient_1 = require("dimensions/blacklistcheckclient");
/**
 * Listens on a specified port and routes users balancing amounts between routing servers it handles
 */
class ListenServer {
    constructor(args) {
        this.limiterInterval = null;
        this.idCounter = 0;
        this.clients = [];
        this.checkingClients = [];
        this.servers = args.servers;
        this.options = args.options;
        this.port = args.info.listenPort;
        this.routingServers = args.info.routingServers;
        this.serversDetails = args.serversDetails;
        this.globalHandlers = args.globalHandlers;
        this.globalTracking = args.globalTracking;
        this.logging = args.logging;
        this.blacklist = args.blacklist;
        this.connectionsTracker = args.connectionsTracker;
        this.connectRateTracker = args.connectRateTracker;
        for (var i = 0; i < this.routingServers.length; i++) {
            this.serversDetails[this.routingServers[i].name] = {
                clientCount: 0,
                disabled: false,
                disabledTimeout: null,
                failedConnAttempts: 0
            };
        }
        this.ServerHandleError = this.handleError.bind(this);
        this.ServerHandleStart = this.handleStart.bind(this);
        // Listen Server
        this.server = Net.createServer();
        this.server.on('connection', (socket) => {
            this.handleSocket(socket)
                .catch((e) => {
                if (this.options.log.clientError) {
                    this.logging.error(`Socket Error: ${errorhelper_1.default.toMessage(e)}`);
                }
            });
        });
        this.server.listen(this.port, this.ServerHandleStart);
        this.server.on('error', this.ServerHandleError);
        if (this.options.connectionRateLimit.enabled) {
            this.startConnectionRateLimitTimer();
        }
    }
    startConnectionRateLimitTimer() {
        this.limiterInterval = setInterval(() => {
            this.connectRateTracker.clear();
        }, 1000);
    }
    /**
     * Finds server with lowest client count
     *
     * @return Either a found routing server or null if one was not found
     */
    chooseServer() {
        let chosenServer = null;
        let currentClientCount = null;
        let details;
        for (let i = 0; i < this.routingServers.length; i++) {
            details = this.serversDetails[this.routingServers[i].name];
            // Even if the server has been disabled, if we have no current choice, we must use it
            if (!details.disabled || currentClientCount === null) {
                // Favour either lower player count or non-disability
                if (currentClientCount === null || chosenServer === null || details.clientCount < currentClientCount || this.serversDetails[chosenServer.name].disabled) {
                    chosenServer = this.routingServers[i];
                    currentClientCount = details.clientCount;
                }
            }
        }
        return chosenServer;
    }
    /**
     * Replaces the current blacklist with a new instance
     */
    loadNewBlacklist(blacklist) {
        this.blacklist = blacklist;
    }
    /**
     * Updates this listen server with its new ownership of routing servers
     *
     * @param info The server configuration containing the routing servers for this listen server
     */
    updateInfo(info) {
        this.port = info.listenPort;
        this.routingServers = info.routingServers;
        // Reset disabled and failedConnAttempts but only
        // reset counts if it didn't already exist as a server
        let details;
        for (let i = 0; i < this.routingServers.length; i++) {
            if (this.serversDetails[this.routingServers[i].name]) {
                details = this.serversDetails[this.routingServers[i].name];
                details.disabled = false;
                details.failedConnAttempts = 0;
            }
            else {
                this.serversDetails[this.routingServers[i].name] = {
                    clientCount: 0,
                    disabled: false,
                    disabledTimeout: null,
                    failedConnAttempts: 0
                };
            }
        }
    }
    /**
     * Destroys all client sockets connected, removing any listeners and resets counts for any servers
     */
    shutdown() {
        this.logging.info(`Server on ${this.port} is now shutting down.`);
        for (let i = 0; i < this.clients.length; i++) {
            this.clients[i].server.socket.removeListener('data', this.clients[i].ServerHandleData);
            this.clients[i].server.socket.removeListener('error', this.clients[i].ServerHandleError);
            this.clients[i].server.socket.removeListener('close', this.clients[i].ServerHandleClose);
            this.clients[i].disconnect(this.options.language.phrases.close);
        }
        this.clients = [];
        this.server.removeListener('error', this.ServerHandleError);
        this.server.close();
        // Reset counts
        let details;
        for (var i = 0; i < this.routingServers.length; i++) {
            details = this.serversDetails[this.routingServers[i].name];
            details.clientCount = 0;
        }
        if (this.limiterInterval !== null) {
            clearInterval(this.limiterInterval);
        }
    }
    /**
     * Logs that the server was started
     */
    handleStart() {
        this.logging.info(`Server on ${this.port} started.`);
    }
    /**
     * Sends the client the disconnect packet and then drops the connection
     *
     * @param socket The socket to disconnect
     * @param reason The reason to disconnect the client
     */
    disconnectClient(socket, reason) {
        let kickPacket = new packetwriter_1.default()
            .setType(packettypes_1.default.Disconnect)
            .packNetworkText(new networktext_1.default(0, reason))
            .data;
        if (!socket.destroyed) {
            socket.write(kickPacket);
            // Allow time for client to receive and process kick packet
            setTimeout(() => {
                socket.destroy();
            }, 1000);
        }
    }
    /**
     * Decrements the number of connections in the tracker for a socket's remote address
     *
     * @param socket The socket that is being disconnected
     */
    decrementConnectionTracker(ip) {
        if (this.options.connectionLimit.enabled) {
            const count = this.connectionsTracker.get(ip);
            if (typeof count !== "undefined") {
                if (count === 1) {
                    this.connectionsTracker.delete(ip);
                }
                else {
                    this.connectionsTracker.set(ip, count - 1);
                }
            }
        }
    }
    /**
     * Gets a server to connect to for a new socket connection, sets up the appropriate handlers
     * and checks if their IP is blacklisted
     *
     * @param socket The socket of a new client
     */
    async handleSocket(socket) {
        if ((this.options.connectionLimit.enabled && this.enforceConnectionLimit(socket))
            || this.options.connectionRateLimit.enabled && this.enforceConnectionRateLimit(socket)) {
            socket.removeAllListeners();
            return;
        }
        for (const extension of Object.values(this.globalHandlers.extensions)) {
            if (extension.socketConnectPreHandler) {
                const handled = await extension.socketConnectPreHandler(socket);
                if (handled) {
                    return;
                }
            }
        }
        this.setupNewSocket(socket);
        for (const extension of Object.values(this.globalHandlers.extensions)) {
            if (extension.socketConnectPostHandler) {
                extension.socketConnectPostHandler(socket);
            }
        }
    }
    enforceConnectionLimit(socket) {
        let connectionDropped = false;
        const ip = socket.remoteAddress;
        if (typeof ip === "undefined") {
            return connectionDropped;
        }
        const counter = this.connectionsTracker.get(ip);
        if (typeof counter !== "undefined") {
            if (counter + 1 > this.options.connectionLimit.connectionLimitPerIP) {
                this.disconnectClient(socket, stringutils_1.default.format(this.options.connectionLimit.kickReason, this.options.connectionLimit.connectionLimitPerIP));
                connectionDropped = true;
            }
            else {
                this.connectionsTracker.set(ip, counter + 1);
            }
        }
        else {
            this.connectionsTracker.set(ip, 1);
        }
        return connectionDropped;
    }
    enforceConnectionRateLimit(socket) {
        let connectionDropped = false;
        const ip = socket.remoteAddress;
        if (typeof ip === "undefined") {
            return connectionDropped;
        }
        const count = this.connectRateTracker.get(ip);
        if (typeof count !== "undefined") {
            if (count + 1 > this.options.connectionRateLimit.connectionRateLimitPerIP) {
                socket.destroy();
                connectionDropped = true;
            }
            else {
                this.connectRateTracker.set(ip, count + 1);
            }
        }
        else {
            this.connectRateTracker.set(ip, 1);
        }
        return connectionDropped;
    }
    /**
     * Checks there is a server available and then sets up listeners and a client object for
     * the socket. Also checking if the ip address of this socket is blacklisted.
     */
    async setupNewSocket(socket) {
        let chosenServer = this.chooseServer();
        if (chosenServer === null) {
            this.logging.warn(`No servers available for ListenServer[Port: ${this.port}]`);
            socket.destroy();
            const ip = socket.remoteAddress;
            if (typeof ip !== "undefined") {
                this.decrementConnectionTracker(ip);
            }
            return;
        }
        // Try using no delay (no buffering of data); maybe set to config option
        if (this.options.socketNoDelay) {
            socket.setNoDelay(true);
        }
        let clientArgs = {
            id: this.idCounter++,
            socket: socket,
            server: chosenServer,
            serversDetails: this.serversDetails,
            globalHandlers: this.globalHandlers,
            servers: this.servers,
            options: this.options,
            globalTracking: this.globalTracking,
            logging: this.logging
        };
        // When the blacklist is enabled, clients must first send their initial data
        // and then get checked before they are allowed to connect to a server
        if (this.options.blacklist.enabled && this.blacklist) {
            const configuration = this.options.blacklist;
            this.sendCheckingIp(clientArgs);
            let client = new blacklistcheckclient_1.default({
                blacklist: this.blacklist,
                clientArgs,
            });
            client.setupCallbacks({
                clientAcceptedCb: (bufferPacket, packetsReceived) => {
                    const index = this.checkingClients.indexOf(client);
                    if (index > -1) {
                        this.checkingClients.splice(index, 1);
                    }
                    this.setupNewClient(clientArgs, bufferPacket, packetsReceived);
                },
                clientBlacklistedCb: () => {
                    const index = this.checkingClients.indexOf(client);
                    if (index > -1) {
                        this.checkingClients.splice(index, 1);
                    }
                    this.kickBlacklisted(clientArgs);
                },
                errorCheckingBlacklistCb: (bufferPacket, packetsReceived, e) => {
                    this.logging.error(`Error checking blacklist: ${errorhelper_1.default.toMessage(e)}`);
                    if (configuration.errorPolicy === "DenyJoining") {
                        const index = this.checkingClients.indexOf(client);
                        if (index > -1) {
                            this.checkingClients.splice(index, 1);
                        }
                        this.disconnectClient(socket, this.options.language.phrases.blacklistCheckError);
                    }
                    else {
                        this.setupNewClient(clientArgs, bufferPacket, packetsReceived);
                    }
                },
                packetErrorCheckingBlacklistCb: (e) => {
                    this.logging.error(`Packet error checking blacklist: ${errorhelper_1.default.toMessage(e)}`);
                    const index = this.checkingClients.indexOf(client);
                    if (index > -1) {
                        this.checkingClients.splice(index, 1);
                    }
                    this.disconnectClient(socket, this.options.language.phrases.blacklistCheckError);
                },
                disconnectCb: () => {
                    const index = this.checkingClients.indexOf(client);
                    if (index > -1) {
                        this.checkingClients.splice(index, 1);
                    }
                    const ip = clientArgs.socket.remoteAddress;
                    if (typeof ip !== "undefined") {
                        this.decrementConnectionTracker(ip);
                    }
                }
            });
            this.checkingClients.push(client);
        }
        else {
            this.setupNewClient(clientArgs, undefined, []);
        }
    }
    setupNewClient(clientArgs, bufferPacket, packetsAlreadyReceived) {
        let client = new client_1.default(clientArgs);
        this.clients.push(client);
        if (this.options.log.clientConnect) {
            this.logging.info(`[Client: ${(0, utils_1.getProperIP)(client.socket.remoteAddress)} connected [${clientArgs.server.name}: ${this.serversDetails[clientArgs.server.name].clientCount + 1}]`);
        }
        this.hookSocketError(client.socket, client);
        this.hookSocketTimeout(client.socket, client);
        this.hookSocketClose(client.socket, client);
        this.hookSocketData(client.socket, client);
        client.handleDataSend(Buffer.concat(packetsAlreadyReceived.map((packet) => packet.data)));
        if (bufferPacket !== undefined) {
            client.handleDataSend(bufferPacket);
        }
        return client;
    }
    /**
     * Checks the blacklist to see if the ip is blacklisted, and will disconnect the socket if they are
     *
     * @param client The client to check the information against the blacklist
     * @return Whether or not the ip is blacklisted
     */
    kickBlacklisted(client) {
        this.disconnectClient(client.socket, this.options.language.phrases.blacklisted);
        if (this.options.log.clientBlocked) {
            this.logging.info(`${process.pid}] Client: ${(0, utils_1.getProperIP)(client.socket.remoteAddress)} was blocked from joining.`);
        }
    }
    /**
     * Tells the client that its information is being checked
     *
     * @param client The client whose information is being checked
     */
    sendCheckingIp(client) {
        const msg = "Checking access...";
        let statusPacket = new packetwriter_1.default()
            .setType(packettypes_1.default.Status)
            .packInt32(1)
            .packNetworkText(new networktext_1.default(0, msg))
            .packByte(0)
            .data;
        client.socket.write(statusPacket);
    }
    /**
     * Hook the socket error and pass it into the client object
     *
     * @param socket The socket of the client to listen for errors on
     * @param client The client object associated with the socket
     */
    hookSocketError(socket, client) {
        socket.once('error', (e) => {
            try {
                client.handleError(e);
            }
            catch (e) {
                if (this.options.log.clientError) {
                    this.logging.error(`handleError Error: ${errorhelper_1.default.toMessage(e)}`);
                }
            }
        });
    }
    /**
     *  Simply destroys any sockets that have triggered the timeout
     *
     * @param socket The socket of the client to listen for timeouts on
     * @param client The client object associated with the socket
     */
    hookSocketTimeout(socket, client) {
        socket.once('timeout', () => {
            if (this.options.log.clientTimeouts) {
                this.logging.warn(`Socket Timeout: ${client.getName()} ${client.ID}`);
            }
            socket.destroy();
        });
    }
    extensionSocketClosePreHandlers(socket, client) {
        try {
            for (const extension of Object.values(this.globalHandlers.extensions)) {
                if (extension.socketClosePreHandler) {
                    const handled = extension.socketClosePreHandler(socket, client);
                    if (handled) {
                        return true;
                    }
                }
            }
        }
        catch (e) {
            if (this.options.log.extensionError) {
                const logMessage = `[${process.pid}] Extension Disconnect Pre Handler Error: ${errorhelper_1.default.toMessage(e)}`;
                this.logging.info(logMessage);
            }
        }
        return false;
    }
    extensionSocketClosePostHandlers(socket, client) {
        try {
            for (const extension of Object.values(this.globalHandlers.extensions)) {
                if (extension.socketClosePostHandler) {
                    extension.socketClosePostHandler(socket, client);
                }
            }
        }
        catch (e) {
            if (this.options.log.extensionError) {
                const logMessage = `[${process.pid}] Extension Disconnect Post Handler Error: ${errorhelper_1.default.toMessage(e)}`;
                this.logging.info(logMessage);
            }
        }
    }
    /**
     * Hook the socket close and pass it into the client object
     *
     * @param socket The socket of the client to listen for closing on
     * @param client The client object associated with the socket
     */
    hookSocketClose(socket, client) {
        socket.once('close', () => {
            if (this.extensionSocketClosePreHandlers(socket, client)) {
                return;
            }
            try {
                const ip = socket.remoteAddress;
                if (typeof ip !== "undefined") {
                    this.decrementConnectionTracker(ip);
                }
                if (this.options.log.clientDisconnect) {
                    const logMessage = `[${process.pid}] Client: ${(0, utils_1.getProperIP)(ip)} disconnected ${client.server.name}: ${this.serversDetails[client.server.name].clientCount - 1}]`;
                    this.logging.info(logMessage);
                }
                client.handleClose();
                for (let i = 0; i < this.clients.length; i++) {
                    if (this.clients[i].ID === client.ID) {
                        this.clients.splice(i, 1);
                        break;
                    }
                }
            }
            catch (e) {
                if (this.options.log.clientError) {
                    this.logging.error(`SocketCloseEvent ERROR: ${errorhelper_1.default.toMessage(e)}`);
                }
            }
            socket.removeAllListeners();
            this.extensionSocketClosePostHandlers(socket, client);
        });
    }
    /**
     * Hook the socket data and pass it into the client object
     *
     * @param socket The socket of the client to listen for data on
     * @param client The client object associated with the socket
     */
    hookSocketData(socket, client) {
        socket.on('data', (data) => {
            try {
                client.handleDataSend(data);
            }
            catch (e) {
                if (this.options.log.clientError) {
                    this.logging.error(`HandleDataSend ERROR: ${errorhelper_1.default.toMessage(e)}`);
                }
            }
        });
        socket.setTimeout(this.options.socketTimeout);
    }
    /**
     * Handles when an error event occurs for this listen server
     *
     * @param error The error object containing the error information
     */
    handleError(error) {
        this.logging.error(` Server on ${this.port} encountered an error: ${errorhelper_1.default.toMessage(error)}.`);
    }
}
exports.ListenServer = ListenServer;
exports.default = ListenServer;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const player_1 = require("dimensions/player");
const terrariaserver_1 = require("dimensions/terrariaserver");
const Net = require("net");
const packettypes_1 = require("dimensions/packettypes");
const packetwriter_1 = require("dimensions/packets/packetwriter");
const networktext_1 = require("dimensions/packets/networktext");
const utils_1 = require("dimensions/utils");
const clientstate_1 = require("dimensions/clientstate");
const errorhelper_1 = require("dimensions/errorhelper");
const clearutils_1 = require("dimensions/clearutils");
const PlayerBuffAdd = require("terraria-packet/src/packet/Packet_PlayerBuffAdd.gen");
/**
 * This class handles switching servers and passing data of a single client
 */
class Client {
    constructor(args) {
        // Queued packets while connecting to a server
        this.queuedPacketsWhileConnecting = [];
        this.ID = args.id;
        // Options from the config
        this.options = args.options;
        // Tracking Information
        this.globalTracking = args.globalTracking;
        // TerrariaServer information available for connecting to
        this.servers = args.servers;
        // The socket connection to the net server associated with this client
        this.socket = args.socket;
        // The unformatted ip address for the current socket connection to the net server
        this.ip = args.socket.remoteAddress;
        // This clients player object which can be used
        // for storing inventory and other player information
        this.player = new player_1.default(this);
        // Global Handlers object whose contents may be updated (reloaded/refreshed)
        this.globalHandlers = args.globalHandlers;
        // For logging errors/info
        this.logging = args.logging;
        // TerrariaServer socket connection and packet handler
        this.server = new terrariaserver_1.default(new Net.Socket(), this);
        this.server.ip = args.server.serverIP;
        this.server.port = args.server.serverPort;
        this.server.name = args.server.name;
        this.server.isVanilla = args.server.isVanilla;
        // Current connection state to TerrariaServer
        this.connected = false;
        // Connection State
        // 0 => Fresh Connection
        // 1 => Finished Sending Inventory
        // 2 => Connection to new server established (extra packet help required because of the actual clients state
        //      being incapable of sending certain packets)
        // 3 => Packet Help sent  Get Section/Request Sync [8] packet in response to world info [7], now waiting on Update Shield Strengths [101]
        // 4 => Spawned on server / Completed Server switch
        // 5 => Disconnected from a terraria server
        this.state = clientstate_1.default.FreshConnection;
        // Incomplete packet from last data received. This is used because all packets are inspected
        this.bufferPacket = Buffer.allocUnsafe(0);
        // This is used to make the first connection to a TerrariaServer after receiving data
        this.initialConnectionAlreadyCreated = false;
        // A boolean of whether the current client has made it in-game (they can see minimap, world, tiles, their inventory)
        this.ingame = false;
        // UUID of client
        this.UUID = "";
        this.waitingCharacterRestore = false;
        // A boolean indicating that the socket was closed because the client was booted from the TerrariaServers
        // This is set to false again after the close handler has been run
        this.wasKicked = false;
        // Information to the server about a type of join (gamemode)
        this.routingInformation = null;
        // Whether or not count was incremented
        // this will be turned off when we minus from count
        this.countIncremented = false;
        // The counts of all TerrariaServers available
        this.serversDetails = args.serversDetails;
        this.preventSpawnOnJoin = false;
        this.ServerHandleError = this.server.handleError.bind(this.server);
        this.ServerHandleData = this.server.handleData.bind(this.server);
        this.ServerHandleClose = this.server.handleClose.bind(this.server);
        // Packets that have been queued as they were sent at the wrong time
        // are stored in the packetQueue
        this.packetQueue = [];
        this.version = "unknown";
    }
    /**
     * Gets the packet handler for this client
     *
     * @return The packet handler
     */
    getPacketHandler() {
        return this.globalHandlers.clientPacketHandler;
    }
    sendExtraInformation() {
        if (this.extraJoinInformation) {
            this.server.socket.write(new packetwriter_1.default()
                .setType(packettypes_1.default.DimensionsUpdate)
                .packInt16(5)
                .packString(this.extraJoinInformation)
                .data);
        }
    }
    /**
     * Sends the disconnect packet and then closes the socket
     *
     * @param reason The reason for the disconnect
     */
    disconnect(reason) {
        if (typeof reason === 'string') {
            reason = new networktext_1.default(0, reason);
        }
        var disconnect = new packetwriter_1.default()
            .setType(packettypes_1.default.Disconnect)
            .packNetworkText(reason)
            .data;
        this.socket.write(disconnect);
        this.socket.pause();
        // Don't disconnect instantly otherwise it will show 'Lost Connection' on client
        setTimeout(() => {
            this.socket.destroy();
        }, 500);
    }
    /**
     * Updates the stored name for this client. Will disconnect them if they try
     * to use a name already in use.
     *
     * @param name The name they are wanting to use
     */
    setName(name) {
        if (this.player.name === name) {
            return;
        }
        // Only change when the name is not in use by another client
        if (this.globalTracking.names[name]) {
            this.disconnect(this.options.language.phrases.nameAlreadyOnServer.replace("${name}", name));
            return;
        }
        if (name.length < 2 || name.length > 20) {
            this.disconnect(this.options.language.phrases.characterNameLengthOutOfRange);
            return;
        }
        if (this.player.name !== "") {
            delete this.globalTracking.names[this.player.name];
        }
        this.player.name = name;
        if (name !== "") {
            this.globalTracking.names[name] = true;
        }
    }
    getName() {
        return this.player.name;
    }
    handleDataSend(encodedData) {
        try {
            // Add Buffer Packet (incomplete packet from last data)
            // to the new data
            let bufferPacket = this.bufferPacket;
            let entireData = Buffer.concat([bufferPacket, encodedData]);
            // Get the individual packets from the data
            let entireDataInfo = (0, utils_1.getPacketsFromBuffer)(entireData);
            if (entireDataInfo.type === "InvalidPacketLength") {
                this.disconnect(this.options.language.phrases.invalidPacketLength);
                return;
            }
            // Update Buffer Packet using the new incomplete packet (if any)
            this.bufferPacket = entireDataInfo.bufferPacket;
            let packets = entireDataInfo.packets;
            // The packets are only handled if the client has already connected
            // to a server for the first time
            if (this.initialConnectionAlreadyCreated) {
                if (this.connected || this.state > clientstate_1.default.FreshConnection) {
                    let allowedData = [];
                    packets.forEach((packet) => {
                        try {
                            const buf = this.getPacketHandler().handlePacket(this, packet);
                            if (buf !== null) {
                                allowedData.push(buf);
                            }
                        }
                        catch (e) {
                            if (this.options.log.clientError) {
                                this.logging.error(`Client handle packet error. PacketType: ${packettypes_1.default[packet.packetType]} (${packet.packetType}): ${errorhelper_1.default.toMessage(e)}. Data: ${packet.data.toString("hex")}`);
                            }
                        }
                    });
                    // Send allowedData to the server if the client is connected to one
                    if (allowedData.length > 0 && this.connected) {
                        if (this.server.socket) {
                            for (const buf of allowedData) {
                                this.server.socket.write(buf);
                            }
                        }
                        else {
                            this.sendChatMessage(this.options.language.phrases.areYouEvenConnected, "ff0000");
                        }
                    }
                }
                else {
                    // Send packets to the server once the client is connected
                    this.queuedPacketsWhileConnecting.push(...packets);
                }
            }
            else {
                // Connect to a server for the first time in this session
                this.initialConnectionAlreadyCreated = true;
                this.player.allowedCharacterChange = true;
                this.player.allowedLifeChange = true;
                this.player.allowedManaChange = true;
                this.player.allowedNameChange = true;
                this.server.socket.on('data', this.ServerHandleData);
                this.server.socket.on('close', this.ServerHandleClose);
                this.server.socket.on('error', this.ServerHandleError);
                this.server.socket.connect(this.server.port, this.server.ip, () => {
                    this.countIncremented = true;
                    this.serversDetails[this.server.name].clientCount++;
                    this.serversDetails[this.server.name].failedConnAttempts = 0;
                    this.connected = true;
                    packets.push(...this.queuedPacketsWhileConnecting);
                    this.queuedPacketsWhileConnecting = [];
                    // In order to allow inspection of first packet regardless of fake version
                    let allowedData = [];
                    packets.forEach((packet) => {
                        const buf = this.getPacketHandler().handlePacket(this, packet);
                        if (buf !== null) {
                            allowedData.push(buf);
                        }
                    });
                    // Write the data the client sent us to the now connected server
                    if (this.options.fakeVersion.enabled) {
                        const verText = "Terraria" + this.options.fakeVersion.terrariaVersion;
                        let packet = new packetwriter_1.default()
                            .setType(1)
                            .packString(verText)
                            .data;
                        this.server.socket.write(packet);
                    }
                    else {
                        // Send allowedData to the server if the client is connected to one
                        if (allowedData.length > 0 && this.connected) {
                            if (this.server.socket) {
                                for (const buf of allowedData) {
                                    this.server.socket.write(buf);
                                }
                            }
                            else {
                                this.sendChatMessage(this.options.language.phrases.areYouEvenConnected, "ff0000");
                            }
                        }
                    }
                });
            }
        }
        catch (e) {
            if (this.options.log.clientError) {
                this.logging.error(`Client Handle Send Data Error: ${errorhelper_1.default.toMessage(e)}`);
            }
        }
    }
    // Useful method for sending a chat message packet to a client */
    sendChatMessage(text, color) {
        if (this.socket.destroyed) {
            return;
        }
        let networkText;
        if (text instanceof networktext_1.default) {
            networkText = text;
        }
        else {
            networkText = new networktext_1.default(0, text);
        }
        if (networkText.text.length > 0) {
            if (typeof color === 'undefined') {
                color = "00ff00";
            }
            let chatMessageData = new packetwriter_1.default()
                .setType(packettypes_1.default.LoadNetModule)
                .packUInt16(1)
                .packByte(255)
                .packNetworkText(networkText)
                .packHex(color)
                .data;
            const chatMessage = { packetType: packettypes_1.default.LoadNetModule, data: chatMessageData };
            const chatMessagePacket = this.server.getPacketHandler().handlePacket(this.server, chatMessage);
            if (chatMessagePacket !== null) {
                this.socket.write(chatMessagePacket);
            }
        }
    }
    /* Sends any queued packets from the connection phase to the server */
    sendWaitingPackets() {
        if (!this.server.socket.destroyed && this.packetQueue.length > 0) {
            for (const packet of this.packetQueue) {
                this.server.socket.write(packet);
            }
            this.packetQueue = [];
        }
    }
    /* Handles switching from one server to another */
    changeServer(server, options) {
        this.extraJoinInformation = options === null || options === void 0 ? void 0 : options.extraJoinInformation;
        clearutils_1.default.clearPlayers(this);
        clearutils_1.default.clearNPCs(this);
        clearutils_1.default.clearItems(this);
        let ip = server.serverIP;
        let port = server.serverPort;
        let name = server.name;
        let isVanilla = server.isVanilla;
        if (typeof options !== 'undefined' && typeof options.preventSpawnOnJoin !== 'undefined') {
            this.preventSpawnOnJoin = options.preventSpawnOnJoin;
        }
        else {
            this.preventSpawnOnJoin = false;
        }
        // Client is now not connected to a server
        this.connected = false;
        this.server.afterClosed = () => {
            // Remove data and error listeners on TerrariaServer socket
            // done AFTER being closed to avoid errors potentially cropping up unhandled
            this.server.socket.removeListener('data', this.ServerHandleData);
            this.server.socket.removeListener('error', this.ServerHandleError);
            this.server.afterClosed = null;
            // Remove close listener now that socket has been closed and event was called
            this.server.socket.removeListener('close', this.ServerHandleClose);
            // Start new socket
            this.server.socket = new Net.Socket();
            if (this.server.isSSC) {
                this.waitingCharacterRestore = true;
            }
            else {
                // Only allow updates to visuals if coming from non-ssc
                this.player.allowedCharacterChange = true;
                this.player.allowedLifeChange = true;
                this.player.allowedManaChange = true;
            }
            this.server.reset();
            this.state = clientstate_1.default.FreshConnection;
            //console.log("Connecting to " + ip + ":" + port);
            // Update server information
            this.server.ip = ip;
            this.server.port = port;
            this.server.name = name;
            this.server.isVanilla = isVanilla;
            // Allow name change during this stage
            this.player.allowedNameChange = true;
            // Debuffs are added to try and prevent a bug in Terraria where a weapon/item can be in use and the slot
            // be changed (due to SSC) causing unintended behaviour
            if (this.options.debuffOnSwitch.enabled) {
                for (const debuffId of this.options.debuffOnSwitch.buffTypes) {
                    const debuff = {
                        data: PlayerBuffAdd.toBuffer({
                            playerId: this.player.id,
                            buff: debuffId,
                            time: 60 * this.options.debuffOnSwitch.debuffTimeInSeconds
                        }),
                        packetType: packettypes_1.default.AddPlayerBuff,
                    };
                    const debuffPacket = this.server.getPacketHandler().handlePacket(this.server, debuff);
                    if (debuffPacket !== null) {
                        this.send(debuffPacket);
                    }
                }
            }
            this.server.socket.on('data', this.ServerHandleData);
            this.server.socket.on('close', this.ServerHandleClose);
            this.server.socket.on('error', this.ServerHandleError);
            // Create connection
            this.server.socket.connect(port, ip, () => {
                if (this.options.log.tServerConnect) {
                    this.logging.info(`[${process.pid}] TerrariaServer Socket Connection [${ip}:${port}]`);
                }
                // Increment server count
                this.countIncremented = true;
                if (!this.serversDetails[this.server.name]) {
                    this.serversDetails[this.server.name] = { clientCount: 0, failedConnAttempts: 0, disabled: false, disabledTimeout: null };
                }
                this.serversDetails[this.server.name].clientCount++;
                this.serversDetails[this.server.name].failedConnAttempts = 0;
                const verText = this.version;
                var connectPacket = new packetwriter_1.default()
                    .setType(1)
                    .packString(verText)
                    .data;
                // Construct Packet object to be handled by any handlers first
                let packet = {
                    packetType: packettypes_1.default.ConnectRequest,
                    data: connectPacket
                };
                const allowedData = this.getPacketHandler().handlePacket(this, packet);
                if (allowedData !== null) {
                    this.server.socket.write(packet.data);
                }
                if (typeof options !== 'undefined' && typeof options.routingInformation !== 'undefined') {
                    this.routingInformation = options.routingInformation;
                }
                this.state = clientstate_1.default.ConnectionSwitchEstablished;
                this.connected = true;
            });
        };
        // Close the TerrariaServer socket completely
        if (!this.server.socket.destroyed) {
            this.server.socket.destroy();
        }
        else {
            this.server.afterClosed(this);
        }
    }
    /**
     * Sends data if the socket is open
     * @param buf
     */
    send(buf) {
        if (!this.socket.destroyed) {
            this.socket.write(buf);
        }
    }
    disconnectFromServer() {
        // Client is now not connected to a server
        this.connected = false;
        this.server.socket.destroy();
        // Remove data and error listeners on TerrariaServer socket
        this.server.socket.removeListener('data', this.ServerHandleData);
        this.server.socket.removeListener('error', this.ServerHandleError);
        this.server.socket.removeListener('close', this.ServerHandleClose);
    }
    handleError(e) {
        if (this.options.log.clientError) {
            this.logging.error(`Client Socket Error: ${errorhelper_1.default.toMessage(e)}`);
        }
    }
    handleClose() {
        //console.log("Client Socket Closed.");
        if (!this.server.socket.destroyed) {
            this.server.afterClosed = null;
            this.server.socket.destroy();
        }
        if (this.getName() !== "") {
            delete this.globalTracking.names[this.getName()];
        }
    }
}
exports.default = Client;

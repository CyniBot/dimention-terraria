"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const packettypes_1 = require("dimensions/packettypes");
const networktext_1 = require("dimensions/packets/networktext");
const packetreader_1 = require("dimensions/packets/packetreader");
const packetwriter_1 = require("dimensions/packets/packetwriter");
const utils_1 = require("dimensions/utils");
const npc_1 = require("dimensions/npc");
const item_1 = require("dimensions/item");
const player_1 = require("dimensions/player");
const clientstate_1 = require("dimensions/clientstate");
const errorhelper_1 = require("dimensions/errorhelper");
const WorldInfo = require("terraria-packet/src/packet/Packet_WorldInfo.gen");
const PlayerInfo = require("terraria-packet/src/packet/Packet_PlayerInfo.gen");
const NpcUpdate = require("terraria-packet/src/packet/Packet_NpcUpdate.gen");
const ItemDropUpdate = require("terraria-packet/src/packet/Packet_ItemDropUpdate.gen");
const PlayerSpawn = require("terraria-packet/src/packet/Packet_PlayerSpawn.gen");
/**
 * This handles all packets coming from a Terraria Server, sometimes responding instead of the client
 * to ensure a smooth and successful transition between servers (due to a client state prohibiting a
 * certain response)
 */
class TerrariaServerPacketHandler {
    /**
     * Checks whether the packet was handled by extensions prior to being processed by this class
     *
     * @param server The server object assigned to a player that is sending a packet
     * @param packet The packet that is being sent
     * @return Whether or not the packet was handled (and should not be sent)
     */
    runPriorHandlers(server, packet) {
        let handlers = server.client.globalHandlers.extensions;
        let handled = false;
        for (let key in handlers) {
            let handler = handlers[key];
            if (typeof handler.priorPacketHandlers !== 'undefined' && typeof handler.priorPacketHandlers.serverHandler !== 'undefined') {
                handled = handler.priorPacketHandlers.serverHandler.handlePacket(server, packet);
                if (handled) {
                    break;
                }
            }
        }
        return handled;
    }
    /**
     * Checks whether the packet was handled by extensions after being processed by this class
     *
     * @param server The server object assigned to a player that is sending a packet
     * @param packet The packet that is being sent
     * @return Whether or not the packet was handled (and should not be sent)
     */
    runPostHandlers(server, packet) {
        let handlers = server.client.globalHandlers.extensions;
        let handled = false;
        for (let key in handlers) {
            let handler = handlers[key];
            if (typeof handler.postPacketHandlers !== 'undefined' && typeof handler.postPacketHandlers.serverHandler !== 'undefined') {
                handled = handler.postPacketHandlers.serverHandler.handlePacket(server, packet);
                if (handled) {
                    break;
                }
            }
        }
        return handled;
    }
    /**
     * Runs the packet through extension handlers and runs any appropriate handlers of this class
     *
     * @param server The server object assigned to a player that is sending a packet
     * @param packet The packet that is being sent
     * @return The packet data (either origin or modified)
     */
    handlePacket(server, packet) {
        this.currentServer = server;
        let priorHandled = this.runPriorHandlers(server, packet);
        if (priorHandled) {
            return null;
        }
        let handled = false;
        let packetType = packet.packetType;
        try {
            switch (packetType) {
                case packettypes_1.default.Disconnect:
                    handled = this.handleDisconnect(packet);
                    break;
                case packettypes_1.default.ContinueConnecting:
                    handled = this.handleContinueConnecting(packet);
                    break;
                case packettypes_1.default.WorldInfo:
                    handled = this.handleWorldInfo(packet);
                    break;
                case packettypes_1.default.CompleteConnectionAndSpawn:
                    handled = this.handleCompleteConnectionAndSpawn(packet);
                    break;
                case packettypes_1.default.DimensionsUpdate:
                    handled = this.handleDimensionsUpdate(packet);
                    break;
                case packettypes_1.default.NPCUpdate:
                    handled = this.handleNPCUpdate(packet);
                    break;
                case packettypes_1.default.UpdateItemDrop_Instanced:
                case packettypes_1.default.UpdateItemDrop:
                    handled = this.handleUpdateItemDrop(packet);
                    break;
                case packettypes_1.default.PlayerActive:
                    handled = this.handlePlayerActive(packet);
                    break;
                case packettypes_1.default.PlayerInventorySlot:
                    handled = this.handlePlayerInventorySlot(packet);
                    break;
                case packettypes_1.default.PlayerInfo:
                    handled = this.handlePlayerInfo(packet);
                    break;
                default:
                    break;
            }
        }
        catch (e) {
            if (server.client.options.log.tServerError) {
                server.client.logging.error(`Dimensions encountered an issue trying to handle a packet from the Terraria Server: ${errorhelper_1.default.toMessage(e)}`);
                if (server.client.state !== clientstate_1.default.FullyConnected) {
                    server.client.sendChatMessage(`A communication error occured.`, "ff0000");
                    server.socket.destroy();
                }
                else {
                    server.client.sendChatMessage(`A communication error occured, this may cause issues with your connection to the server.`, "ff0000");
                }
            }
        }
        if (handled) {
            return null;
        }
        let postHandled = this.runPostHandlers(server, packet);
        if (postHandled) {
            return null;
        }
        return packet.data;
    }
    /**
     * Passes on the disconnect message as a chat message to the client, unless the client
     * has not fully connected to any Dimension yet.
     *
     * @param packet The disconnect packet
     * @return Whether or not this packet was handled (and should not be sent)
     */
    handleDisconnect(packet) {
        let client = this.currentServer.client;
        let reader = new packetreader_1.default(packet.data);
        var dcReason = reader.readNetworkText();
        if (!client.ingame) {
            client.disconnect(dcReason);
        }
        else {
            let reader = new packetreader_1.default(packet.data);
            var dcReason = reader.readNetworkText();
            var color = "C8FF00";
            var message = client.options.language.phrases.dimensionDisconnectedYou;
            const disconnectOnKick = client.options.disconnectOnKick;
            switch (disconnectOnKick.type) {
                case "always":
                    client.disconnect(dcReason);
                    return true;
                case "never":
                    break;
                case "onKickReasonPrefix":
                    for (const prefix of disconnectOnKick.kickReasonPrefixes) {
                        if (dcReason.mode === 0 && dcReason.text.startsWith(prefix)) {
                            client.disconnect(dcReason.text.substring(prefix.length));
                            return true;
                        }
                    }
                    break;
            }
            client.sendChatMessage(message, color);
            client.sendChatMessage(new networktext_1.default(1, client.options.language.phrases.reason + "{0}", [dcReason]), color);
            client.wasKicked = true;
            client.connected = false;
            if (this.socket) {
                this.socket.destroy();
            }
        }
        return true;
    }
    /**
     * Passes on the real IP of the client to the server
     *
     * @param packet The continue connecting packet
     * @return Whether or not this packet was handled (and should not be sent)
     */
    handleContinueConnecting(packet) {
        let reader = new packetreader_1.default(packet.data);
        this.currentServer.client.player.id = reader.readByte();
        // Send IP Address
        if (!this.currentServer.isVanilla) {
            let ip = (0, utils_1.getProperIP)(this.currentServer.client.socket.remoteAddress);
            const packetData = new packetwriter_1.default()
                .setType(packettypes_1.default.DimensionsUpdate)
                .packInt16(0) // Type
                .packString(ip)
                .data;
            this.currentServer.socket.write(packetData);
        }
        return false;
    }
    /**
     * Restores player data and updates the SSC tracking
     *
     * @param packet The world info packet
     * @return Whether or not this packet was handled (and should not be sent)
     */
    handleWorldInfo(packet) {
        const worldInfo = WorldInfo.parse(packet.data);
        if (typeof worldInfo === 'undefined') {
            return false;
        }
        this.currentServer.isSSC = worldInfo.eventInfo.serverSidedCharacters;
        if (this.currentServer.client.waitingCharacterRestore && !this.currentServer.isSSC) {
            this.restoreInventory(this.currentServer.client);
            this.restoreLife(this.currentServer.client);
            this.restoreMana(this.currentServer.client);
            this.restoreVisuals(this.currentServer.client);
        }
        this.currentServer.client.waitingCharacterRestore = false;
        if (this.currentServer.client.state === clientstate_1.default.ConnectionSwitchEstablished) {
            this.currentServer.spawn.x = worldInfo.spawnX;
            this.currentServer.spawn.y = worldInfo.spawnY;
            // In future it would be better to check if they used a warpplate
            // so the tile section is where they came through instead of spawn
            let getSection = new packetwriter_1.default()
                .setType(packettypes_1.default.GetSectionOrRequestSync)
                .packSingle(-1)
                .packSingle(-1)
                .data;
            this.currentServer.socket.write(getSection);
            this.currentServer.client.state = clientstate_1.default.FinalisingSwitch;
            // Routing Information for Warpplate entry
            if (this.currentServer.client.routingInformation !== null) {
                let dimensionsUpdate = new packetwriter_1.default()
                    .setType(packettypes_1.default.DimensionsUpdate)
                    .packInt16(this.currentServer.client.routingInformation.type)
                    .packString(this.currentServer.client.routingInformation.info)
                    .data;
                this.currentServer.socket.write(dimensionsUpdate);
                this.currentServer.client.routingInformation = null;
            }
        }
        return false;
    }
    /**
     * Ensures the player spawns correctly by sending the SpawnPlayer packet
     * that forces them to spawn if they're already in-game (on the world
     *
     * @param _packet The complete connection and spawn packet
     * @return Whether or not the packet has been handled (and is not to be sent)
     */
    handleCompleteConnectionAndSpawn(_packet) {
        let server = this.currentServer;
        if (this.currentServer.client.state === clientstate_1.default.FinalisingSwitch) {
            this.currentServer.client.state = clientstate_1.default.FinishinedSendingInventory;
            let spawnPlayer = PlayerSpawn.toBuffer({
                playerId: this.currentServer.client.player.id,
                x: this.currentServer.spawn.x,
                y: this.currentServer.spawn.y,
                context: "SpawningIntoWorld",
                timeRemaining: 0,
                numberOfDeathsPve: 0,
                numberOfDeathsPvp: 0
            });
            if (typeof server.client !== 'undefined' && typeof server.client.socket !== 'undefined') {
                server.socket.write(spawnPlayer);
                if (!server.client.preventSpawnOnJoin) {
                    server.client.socket.write(spawnPlayer);
                }
            }
        }
        if (server.client.state === clientstate_1.default.FinishinedSendingInventory) {
            server.client.state = clientstate_1.default.FullyConnected;
            server.client.sendWaitingPackets();
            server.sendWaitingPackets();
            server.client.sendExtraInformation();
            for (let key in server.client.globalHandlers.extensions) {
                const e = server.client.globalHandlers.extensions[key];
                if (e.clientFullyConnectedHandler) {
                    e.clientFullyConnectedHandler(server.client);
                }
            }
        }
        this.currentServer.client.ingame = true;
        return false;
    }
    /**
     * Handles the event that a warpplate requests switch of Dimension
     *
     * @param packet The dimensions update packet
     * @return Whether or not the packet has been handled (and is not to be sent)
     */
    handleDimensionsUpdate(packet) {
        const reader = new packetreader_1.default(packet.data);
        const messageType = reader.readInt16();
        const messageContent = reader.readString();
        // Switch server
        if (messageType === 2) {
            if (this.currentServer.client.servers[messageContent.toLowerCase()]) {
                const phrases = this.currentServer.client.options.language.phrases;
                this.currentServer.client.sendChatMessage(phrases.shiftingToDimension.replace("${name}", messageContent), "FF0000");
                this.currentServer.client.changeServer(this.currentServer.client.servers[messageContent.toLowerCase()], {
                    preventSpawnOnJoin: false
                });
            }
        }
        if (messageType === 3) {
            const currentServerIp = this.currentServer.socket.remoteAddress;
            let ip = messageContent;
            const port = reader.readUInt16();
            if (ip === "127.0.0.1" && typeof currentServerIp !== "undefined") {
                ip = currentServerIp;
            }
            this.currentServer.client.changeServer({
                name: `${ip}:${port}`,
                serverIP: ip,
                serverPort: port,
                hidden: false,
                isVanilla: false,
            }, {
                preventSpawnOnJoin: false
            });
        }
        if (messageType === 4) {
            if (this.currentServer.client.servers[messageContent.toLowerCase()]) {
                const extraJoinInformation = reader.readString();
                const phrases = this.currentServer.client.options.language.phrases;
                this.currentServer.client.sendChatMessage(phrases.shiftingToDimension.replace("${name}", messageContent), "FF0000");
                this.currentServer.client.changeServer(this.currentServer.client.servers[messageContent.toLowerCase()], {
                    preventSpawnOnJoin: false,
                    extraJoinInformation,
                });
            }
        }
        return true;
    }
    /**
     * Tracks whether an NPC is alive or not, so it can be cleared when the player switches Dimensions
     *
     * @param packet The NPC Update
     * @return Whether or not the packet has been handled (and is not to be sent)
     */
    handleNPCUpdate(packet) {
        const npcUpdate = NpcUpdate.parse(packet.data);
        if (typeof npcUpdate === "undefined") {
            return false;
        }
        const { npcSlotId, npcTypeId, life } = npcUpdate;
        let zeroLife = false;
        if (life != "Max") {
            zeroLife = life._0 === 0;
        }
        if (npcTypeId === 0 || zeroLife) {
            this.currentServer.entityTracking.NPCs[npcSlotId] = undefined;
        }
        else {
            let npc = this.currentServer.entityTracking.NPCs[npcSlotId];
            if (npc === undefined) {
                this.currentServer.entityTracking.NPCs[npcSlotId] = new npc_1.default(npcSlotId, npcTypeId, life === "Max" ? 1 : life._0);
            }
            else {
                npc.life = life === "Max" ? 1 : life._0;
                npc.type = npcTypeId;
            }
        }
        return false;
    }
    /**
     * Tracks item drops so they can be cleared when the player switches Dimensions
     *
     * @param packet The update item drop packet
     * @return Whether or not this packet was handled (and should not be sent)
     */
    handleUpdateItemDrop(packet) {
        const itemDropUpdate = ItemDropUpdate.parse(packet.data);
        if (typeof itemDropUpdate === "undefined") {
            return false;
        }
        const { itemDropId, stack, prefix, itemId } = itemDropUpdate;
        if (itemDropId > 0) {
            this.currentServer.entityTracking.items[itemDropId] = new item_1.default(itemDropId, stack, prefix, itemId);
        }
        else {
            this.currentServer.entityTracking.items[itemDropId] = undefined;
        }
        return false;
    }
    /**
     * Tracks which players are active so they can be cleared when a player switches Dimensions
     *
     * @param packet The player active packet
     * @return Whether or not this packet was handled (and should not be sent)
     */
    handlePlayerActive(packet) {
        let reader = new packetreader_1.default(packet.data);
        let playerID = reader.readByte();
        let active = reader.readByte() === 1;
        let player = undefined;
        if (active) {
            player = new player_1.default(null);
        }
        this.currentServer.entityTracking.players[playerID] = player;
        return false;
    }
    /**
     * Holds back slot updates until player is ready to spawn for the first time
     * on the current Dimension
     *
     * @param packet The player inventory slot packet
     */
    handlePlayerInventorySlot(packet) {
        let handled = false;
        let reader = new packetreader_1.default(packet.data);
        let playerID = reader.readByte();
        if (playerID === this.currentServer.client.player.id) {
            if (this.currentServer.client.state !== clientstate_1.default.FullyConnected) {
                this.currentServer.packetQueue.push(packet.data);
                handled = true;
            }
        }
        return handled;
    }
    handlePlayerInfo(packet) {
        var _a, _b, _c;
        const playerInfo = PlayerInfo.parse(packet.data);
        if (typeof playerInfo === "undefined") {
            return false;
        }
        const nameMismatchesRequireRewrite = ((_a = this.currentServer.client.options.nameChanges) === null || _a === void 0 ? void 0 : _a.mode) === "rewrite";
        const isAboutCurrentClient = playerInfo.playerId === this.currentServer.client.player.id;
        const isMismatchedName = this.currentServer.client.player.name !== playerInfo.name;
        const isAllowedToRename = ((_c = (_b = this.currentServer.client.options.nameChanges) === null || _b === void 0 ? void 0 : _b.exclusions.indexOf(this.currentServer.name)) !== null && _c !== void 0 ? _c : -1) > -1;
        if (nameMismatchesRequireRewrite && isAboutCurrentClient && isMismatchedName) {
            if (!isAllowedToRename) {
                packet.data = PlayerInfo.toBuffer(Object.assign(Object.assign({}, playerInfo), { name: this.currentServer.client.player.name }));
            }
            else {
                this.currentServer.client.setName(playerInfo.name);
            }
        }
        return false;
    }
    /**
     * Sets the players slots back to what they were before they joined the SSC server.
     * Used when a player switches from an SSC server to a non-SSC server
     *
     * @param client Which client is getting its inventory restored
     */
    restoreInventory(client) {
        for (const item of this.currentServer.client.player.inventory) {
            if (typeof item !== "undefined") {
                client.player.setItem(item);
            }
        }
    }
    /**
     * Sets the players life back to what they were before they joined the SSC server.
     * Used when a player switches from an SSC server to a non-SSC server
     *
     * @param client Which client is getting its life restored
     */
    restoreLife(client) {
        client.player.restoreSavedMaxHealth();
    }
    /**
     * Sets the players mana back to what they were before they joined the SSC server.
     * Used when a player switches from an SSC server to a non-SSC server
     *
     * @param client Which client is getting its mana restored
     */
    restoreMana(client) {
        client.player.restoreSavedMaxMana();
    }
    /**
     * Sets the players visuals back to what they were before they joined the SSC server.
     * Used when a player switches from an SSC server to a non-SSC server
     *
     * @param client Which client is getting its visuals restored
     */
    restoreVisuals(client) {
        client.player.setVisuals();
    }
}
;
exports.default = TerrariaServerPacketHandler;

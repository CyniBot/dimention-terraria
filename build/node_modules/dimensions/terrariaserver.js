"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("dimensions/utils");
const packettypes_1 = require("dimensions/packettypes");
const clientstate_1 = require("dimensions/clientstate");
const errorhelper_1 = require("dimensions/errorhelper");
/* Used to track information specific to the current server that a client is on
 * as well as pass received data from the TerrariaServer to the handlers */
class TerrariaServer {
    constructor(socket, client) {
        this.socket = socket;
        this.client = client;
        this.reset();
    }
    reset() {
        this.ip = "127.0.0.1";
        this.port = 7777;
        this.isVanilla = false;
        this.name = "";
        this.spawn = {
            x: 0,
            y: 0
        };
        this.bufferPacket = Buffer.allocUnsafe(0);
        this.afterClosed = null;
        this.entityTracking = {
            items: [],
            NPCs: [],
            players: []
        };
        this.isSSC = false;
        this.packetQueue = [];
    }
    getPacketHandler() {
        return this.client.globalHandlers.terrariaServerPacketHandler;
    }
    /* Handles all data coming from the TerrariaServer */
    handleData(encodedData) {
        try {
            // This is the incomplete packet carried over from last time
            let bufferPacket = this.bufferPacket;
            // The combined packet info using buffer
            let entireData = Buffer.concat([bufferPacket, encodedData]);
            // Get an array of packets from the entireData
            let entireDataInfo = (0, utils_1.getPacketsFromBuffer)(entireData);
            if (entireDataInfo.type === "InvalidPacketLength") {
                this.client.logging.error(`Terraria Server Packet Length Error: Received Packet Length ${entireDataInfo.length}`);
                this.client.sendChatMessage("Disconnected from dimension due to a packet length error. Please try again.");
                this.client.disconnectFromServer();
                return;
            }
            // Update buffer packet to the new incomplete packet (if any)
            this.bufferPacket = entireDataInfo.bufferPacket;
            // The hex string of the allowed packets to send to the client
            let allowedPackets = [];
            // Inspect and handle each packet
            let packets = entireDataInfo.packets;
            packets.forEach((packet) => {
                try {
                    const buf = this.getPacketHandler().handlePacket(this, packet);
                    if (buf !== null) {
                        allowedPackets.push(buf);
                    }
                }
                catch (e) {
                    if (this.client.options.log.tServerError) {
                        this.client.logging.error(`TS handle packet error. PacketType: ${packettypes_1.default[packet.packetType]} (${packet.packetType}): ${errorhelper_1.default.toMessage(e)}. Data: ${packet.data.toString("hex")}`);
                    }
                }
            });
            if (allowedPackets.length > 0) {
                if (!this.client.socket.destroyed && this.client.socket.writable) {
                    for (const buf of allowedPackets) {
                        this.client.socket.write(buf);
                    }
                }
                else {
                    this.socket.destroy();
                }
            }
        }
        catch (e) {
            if (this.client.options.log.tServerError) {
                this.client.logging.error(`TS Handle Data Error: ${errorhelper_1.default.toMessage(e)}`);
            }
        }
    }
    /* Sends any queued packets from the connection phase to the client */
    sendWaitingPackets() {
        if (!this.socket.destroyed && this.packetQueue.length > 0) {
            for (const packet of this.packetQueue) {
                this.client.socket.write(packet);
            }
            this.packetQueue = [];
        }
    }
    /* Calls all server disconnect pre-handlers from extensions
     * and returns whether the disconnect was handled by them.*/
    handledByPreCloseHandlers() {
        let handlers = this.client.globalHandlers.extensions;
        let handled = false;
        for (let key in handlers) {
            let handler = handlers[key];
            if (typeof handler.serverDisconnectPreHandler !== 'undefined') {
                handled = handler.serverDisconnectPreHandler(this);
                if (handled) {
                    break;
                }
            }
        }
        return handled;
    }
    /* Calls all server disconnect handlers from extensions
     * and returns whether the disconnect was handled by them.*/
    handledByCloseHandlers() {
        let handlers = this.client.globalHandlers.extensions;
        let handled = false;
        for (let key in handlers) {
            let handler = handlers[key];
            if (typeof handler.serverDisconnectHandler !== 'undefined') {
                handled = handler.serverDisconnectHandler(this);
                if (handled) {
                    break;
                }
            }
        }
        return handled;
    }
    /* Decrements server counts when the socket connection to the TerrariaServer
     * is closed, sends a message to the client and runs any handlers of this
     * event through extensions currently loaded */
    handleClose() {
        this.client.connected = false;
        try {
            if (this.client.countIncremented) {
                this.client.serversDetails[this.name].clientCount--;
                this.client.countIncremented = false;
            }
        }
        catch (e) {
            if (this.client.options.log.tServerError) {
                this.client.logging.error(`handleClose ERROR: ${errorhelper_1.default.toMessage(e)}`);
            }
        }
        if (this.client.options.log.tServerDisconnect) {
            this.client.logging.info(`TerrariaServer socket closed. [${this.name}]`);
        }
        if (this.handledByPreCloseHandlers()) {
            return;
        }
        if (this.afterClosed !== null) {
            this.afterClosed(this.client);
        }
        else {
            if (this.handledByCloseHandlers()) {
                return;
            }
            let dimensionsList = "";
            let dimensionNames = Object.keys(this.client.servers);
            for (var i = 0; i < dimensionNames.length; i++) {
                let name = dimensionNames[i];
                let hidden = this.client.servers[name].hidden;
                if (!hidden) {
                    dimensionsList += (i > 0 ? ", " : " ") + "/" + dimensionNames[i];
                }
            }
            if (!this.client.wasKicked) {
                this.client.sendChatMessage(this.client.options.language.phrases.dimensionDropped, "00BFFF");
                this.client.sendChatMessage(this.client.options.language.phrases.specifyADimensionToTravel + dimensionsList, "00BFFF");
            }
            else {
                this.client.sendChatMessage(this.client.options.language.phrases.specifyADimensionToTravel + dimensionsList, "00BFFF");
                this.client.wasKicked = false;
            }
            this.client.state = clientstate_1.default.Disconnected;
        }
    }
    /* Checks the type of error, if it is because a server is down, the failed connection attempts
     * property is incremented until it reaches 3 at which point it is marked as closed and will not
     * be used by clients.
     *
     * TODO: Handle non-refused errors when the host itself is offline */
    handleError(error) {
        //console.log(this.ip + ":" + this.port + " " + this.name);
        //this.client.changeServer(Config.IP, Config.PORT);
        let matches = / E([A-z]*?) /.exec(error.message);
        let type = matches !== null && matches.length > 1 ? matches[1] : "";
        let serverDetails = this.client.serversDetails[this.name];
        if (type === "CONNREFUSED" || type === "TIMEDOUT") {
            if (!serverDetails.disabled && ++serverDetails.failedConnAttempts >= 3) {
                serverDetails.disabled = true;
                serverDetails.disabledTimeout = setTimeout(() => {
                    serverDetails.failedConnAttempts = 0;
                    serverDetails.disabled = false;
                }, 20000);
            }
        }
        if (this.client.options.log.tServerError) {
            this.client.logging.error(`TerrariaServer Socket Error: ${errorhelper_1.default.toMessage(error)}`);
        }
    }
}
exports.default = TerrariaServer;

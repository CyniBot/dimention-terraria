"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const networktext_1 = require("dimensions/packets/networktext");
const utils_1 = require("dimensions/utils");
const utf8 = require("utf8");
/**
 * Reads datatypes from a hex string
 */
class BufferReader {
    constructor(data) {
        this.head = 0;
        this._data = data;
    }
    /**
     * Gets the data still stored by the reader
     *
     * @return The hex data still stored by the reader
     */
    get data() {
        return this._data;
    }
    set buffer(data) {
        this._data = data;
        this.head = 0;
    }
    /**
     * Reads a byte from the data
     *
     * @return The byte removed
     */
    readByte() {
        const byte = this._data.readUInt8(this.head);
        this.head += 1;
        return byte;
    }
    /**
     * Reads a certain number of bytes from the data
     *
     * @return The bytes removed
     */
    readBytes(amount) {
        const bytes = [];
        for (let i = 0; i < amount; i++) {
            bytes.push(this.readByte());
        }
        return bytes;
    }
    /**
     * Reads a chunk of data and returns it in a buffer
     *
     * @param size The number of bytes to read
     */
    readBuffer(size) {
        const buffer = this._data.slice(this.head, this.head + size);
        this.head += size;
        return buffer;
    }
    /**
     * Reads three bytes from the data and puts them into a color object
     *
     * @return The color object {R, G, B}
     */
    readColor() {
        const color = {
            R: this.readByte(),
            G: this.readByte(),
            B: this.readByte()
        };
        return color;
    }
    /**
     * Reads a byte and converts it into an sbyte
     *
     * @return The sbyte removed
     */
    readSByte() {
        const byte = this._data.readInt8(this.head);
        this.head += 1;
        return byte;
    }
    /**
     * Reads 2 bytes from the data, converting it to a signed int16
     * as an int16.
     *
     * @return An int16
     */
    readInt16() {
        const int16 = this._data.readInt16LE(this.head);
        this.head += 2;
        return int16;
    }
    /**
     * Reads 2 bytes from the data and converts it to an unsigned int16
     *
     * @return A uint16
     */
    readUInt16() {
        const uint16 = this._data.readUInt16LE(this.head);
        this.head += 2;
        return uint16;
    }
    /**
     * Reads 4 bytes from the data, converting it into a signed int32
     *
     * Perf: https://jsperf.com/conv-dimen-1
     * @return The signed int32 removed from the data
     */
    readInt32() {
        const int32 = this._data.readInt32LE(this.head);
        this.head += 4;
        return int32;
    }
    /**
     * Reads 4 bytes from the data, converting it into an unsigned int32
     *
     * @return The unsigned int32 removed from the data
     */
    readUInt32() {
        const uint32 = this._data.readUInt32LE(this.head);
        this.head += 4;
        return uint32;
    }
    /**
     * Reads 8 bytes from the data, converting it into an unsigned int64
     *
     * @return The unsigned int64 removed from the data
     */
    readUInt64() {
        const low = this.readUInt32();
        const high = this.readUInt32();
        return low + high * 4294967296.0;
    }
    /**
     * Reads 4 bytes from the data converting it into a single
     *
     * @return The single removed from the data
     */
    readSingle() {
        const single = this._data.readFloatLE(this.head);
        this.head += 4;
        return single;
    }
    /**
     * Reads a certain number of bytes for the string length, and then further
     * bytes depending on the length, converting it into a string of characters.
     *
     * @return The string removed from the data
     */
    readString() {
        // Read string length
        const firstByte = this.readByte();
        let strLength = firstByte;
        if (firstByte >= 128) {
            const secondByte = this.readByte();
            strLength = (firstByte - 128) + (secondByte << 7);
        }
        // Read string content using length
        const rawText = (0, utils_1.bufferToText)(this._data.slice(this.head, this.head + strLength));
        const strContent = utf8.decode(rawText);
        this.head += strLength;
        return strContent;
    }
    /**
     * Reads the mode byte and the string bytes
     *
     * @return The text
     */
    readNetworkText() {
        const mode = this.readByte();
        const text = this.readString();
        let substitutionList;
        // If mode is not Literal
        if (mode != 0) {
            // Parse the substitution list
            const substitutionListLength = this.readByte();
            if (substitutionListLength > 0) {
                substitutionList = new Array(substitutionListLength);
                for (let i = 0; i < substitutionListLength; i++) {
                    substitutionList[i] = this.readNetworkText();
                }
            }
        }
        return new networktext_1.default(mode, text, substitutionList);
    }
}
exports.default = BufferReader;

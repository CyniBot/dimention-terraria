"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("dimensions/utils");
const utf8 = require("utf8");
class BufferWriter {
    constructor(size) {
        this._offset = 0;
        this._buffer = Buffer.allocUnsafe(size);
    }
    changeOffset(offset) {
        this._offset = offset;
    }
    packInt16(int16) {
        this._buffer.writeInt16LE(int16, this._offset);
        this._offset += 2;
        return this;
    }
    packUInt16(uint16) {
        this._buffer.writeUInt16LE(uint16, this._offset);
        this._offset += 2;
        return this;
    }
    packInt32(int32) {
        this._buffer.writeInt32LE(int32, this._offset);
        this._offset += 4;
        return this;
    }
    packUInt32(uint32) {
        this._buffer.writeUInt32LE(uint32, this._offset);
        this._offset += 4;
        return this;
    }
    packUInt64(uint64) {
        this.packUInt32(uint64 >> 8);
        this.packUInt32(uint64 & 0x00ff);
        return this;
    }
    packSingle(single) {
        this._buffer.writeFloatLE(single, this._offset);
        this._offset += 4;
        return this;
    }
    packByte(byte) {
        if (byte < 0)
            byte = -byte;
        this._buffer.writeUInt8(byte, this._offset);
        this._offset += 1;
        return this;
    }
    packSByte(byte) {
        this._buffer.writeInt8(byte, this._offset);
        this._offset += 1;
        return this;
    }
    packBytes(bytes) {
        for (const byte of bytes) {
            this.packByte(byte);
        }
        return this;
    }
    packHex(hex) {
        const buf = Buffer.from(hex, "hex");
        buf.copy(this._buffer, this._offset, 0);
        this._offset += buf.length;
        return this;
    }
    packBuffer(buffer) {
        buffer.copy(this._buffer, this._offset, 0);
        this._offset += buffer.length;
        return this;
    }
    packString(str) {
        const packedStr = (0, utils_1.textToBuffer)(utf8.encode(str));
        const strLen = packedStr.length;
        if (strLen >= 128) {
            this.packByte((strLen % 128) + 128);
            this.packByte(Math.floor(strLen / 128));
        }
        else {
            this.packByte(strLen);
        }
        this.packBuffer(packedStr);
        return this;
    }
    packColor(color) {
        this.packByte(color.R);
        this.packByte(color.G);
        this.packByte(color.B);
        return this;
    }
    packNetworkText(networkText) {
        this.packByte(networkText.mode);
        this.packString(networkText.text);
        if (networkText.substitutionList) {
            this.packByte(networkText.substitutionList.length);
            for (let i = 0; i < networkText.substitutionList.length; i++) {
                this.packNetworkText(networkText.substitutionList[i]);
            }
        }
        else if (networkText.mode != 0) {
            this.packByte(0);
        }
        return this;
    }
    get data() {
        return this._buffer;
    }
    get slicedData() {
        return this._buffer.slice(0, this._offset);
    }
}
exports.default = BufferWriter;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPackedStringByteLen = exports.requireNoCache = exports._invalidateRequireCacheForFile = exports.getPacketsFromBuffer = exports.getPacketTypeFromBuffer = exports.getProperIP = exports.textToBuffer = exports.bufferToText = void 0;
const path = require("path");
const bufferreader_1 = require("dimensions/packets/bufferreader");
const utf8 = require("utf8");
const packetwriter_1 = require("dimensions/packets/packetwriter");
const bufferwriter_1 = require("dimensions/packets/bufferwriter");
function bufferToText(buf) {
    const reader = new bufferreader_1.default(buf);
    let str = '';
    for (let i = 0; i < buf.length; i++) {
        str += String.fromCharCode(reader.readByte());
    }
    return str;
}
exports.bufferToText = bufferToText;
function textToBuffer(str) {
    const writer = new packetwriter_1.default(bufferwriter_1.default);
    for (var i = 0, l = str.length; i < l; i++) {
        writer.packByte(str.charCodeAt(i));
    }
    return writer.data;
}
exports.textToBuffer = textToBuffer;
function getProperIP(ip) {
    if (typeof ip === "undefined")
        return undefined;
    let IPFromRequest = ip;
    let indexOfColon = IPFromRequest.lastIndexOf(':');
    let IP = IPFromRequest.substring(indexOfColon + 1, IPFromRequest.length);
    return IP;
}
exports.getProperIP = getProperIP;
function getPacketTypeFromBuffer(buf) {
    return buf.readUInt8(2);
}
exports.getPacketTypeFromBuffer = getPacketTypeFromBuffer;
function getPacketsFromBuffer(buf) {
    const reader = new bufferreader_1.default(buf);
    let packets = [];
    let end = false;
    let length;
    let data;
    let packetType;
    let bufferPacket = Buffer.allocUnsafe(0);
    if (buf.length > 1) {
        while (!end) {
            length = reader.readUInt16();
            if (length === 0 || length === 1) {
                return { type: "InvalidPacketLength", length };
            }
            else {
                // - 2, so that we capture the two length bytes already read
                data = buf.slice(reader.head - 2, reader.head - 2 + length);
                // -2 here because length includes 2 bytes already read
                reader.head += length - 2;
                if (reader.head > buf.length) {
                    bufferPacket = data;
                    end = true;
                }
                else {
                    packetType = getPacketTypeFromBuffer(data);
                    packets.push({
                        packetType: packetType,
                        data: data
                    });
                    // Need at least 2 bytes for the next length int16
                    if (reader.head === buf.length - 1) {
                        bufferPacket = buf.slice(buf.length - 1, buf.length);
                        end = true;
                        // No more bytes to read
                    }
                    else if (reader.head === buf.length) {
                        end = true;
                    }
                }
            }
        }
    }
    else {
        bufferPacket = buf.slice(0, 1);
    }
    return { type: "ValidPackets", bufferPacket: bufferPacket, packets: packets };
}
exports.getPacketsFromBuffer = getPacketsFromBuffer;
function _invalidateRequireCacheForFile(filePath, require) {
    var realPath = path.resolve(filePath);
    delete require.cache[realPath];
}
exports._invalidateRequireCacheForFile = _invalidateRequireCacheForFile;
function requireNoCache(filePath, require) {
    _invalidateRequireCacheForFile(filePath, require);
    return require(filePath);
}
exports.requireNoCache = requireNoCache;
function getPackedStringByteLen(str) {
    const strLen = textToBuffer(utf8.encode(str)).length;
    if (str.length >= 128) {
        return 2 + strLen;
    }
    return 1 + strLen;
}
exports.getPackedStringByteLen = getPackedStringByteLen;
